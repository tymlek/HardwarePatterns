; Listing generated by Microsoft (R) Optimizing Compiler Version 19.12.25835.0 

	TITLE	C:\Users\Tim\School\Level 6\CI6300 Individual Project\Code\Patterns\HardwarePatterns\HardwareProxyPatternCpp\MotorProxy.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?configure@MotorProxy@@QAEXIPAI@Z		; MotorProxy::configure
PUBLIC	?initialize@MotorProxy@@QAEXXZ			; MotorProxy::initialize
PUBLIC	?getMotorDirection@MotorProxy@@QAE?AW4DirectionType@@XZ ; MotorProxy::getMotorDirection
PUBLIC	?getMotorSpeed@MotorProxy@@QAEIXZ		; MotorProxy::getMotorSpeed
PUBLIC	?getMotorState@MotorProxy@@QAEIXZ		; MotorProxy::getMotorState
PUBLIC	?setMotorSpeed@MotorProxy@@QAEXW4DirectionType@@I@Z ; MotorProxy::setMotorSpeed
PUBLIC	?clearErrorStatus@MotorProxy@@QAEXXZ		; MotorProxy::clearErrorStatus
PUBLIC	?disable@MotorProxy@@QAEXXZ			; MotorProxy::disable
PUBLIC	?enable@MotorProxy@@QAEXXZ			; MotorProxy::enable
PUBLIC	?marshal@MotorProxy@@AAEIABUMotorData@@@Z	; MotorProxy::marshal
PUBLIC	?unmarshal@MotorProxy@@AAE?AUMotorData@@I@Z	; MotorProxy::unmarshal
PUBLIC	__real@4000000000000000
PUBLIC	__real@400921f9f01b866e
PUBLIC	__real@4024000000000000
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@400921f9f01b866e
CONST	SEGMENT
__real@400921f9f01b866e DQ 0400921f9f01b866er	; 3.14159
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\tim\school\level 6\ci6300 individual project\code\patterns\hardwarepatterns\hardwareproxypatterncpp\motorproxy.cpp
;	COMDAT ?unmarshal@MotorProxy@@AAE?AUMotorData@@I@Z
_TEXT	SEGMENT
_temp$ = -52						; size = 4
_mData$ = -40						; size = 20
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_encodedMData$ = 12					; size = 4
?unmarshal@MotorProxy@@AAE?AUMotorData@@I@Z PROC	; MotorProxy::unmarshal, COMDAT
; _this$ = ecx

; 196  : MotorData MotorProxy::unmarshal(std::uint32_t encodedMData) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f8 00 00
	00		 sub	 esp, 248		; 000000f8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 08 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-248]
  00013	b9 3e 00 00 00	 mov	 ecx, 62			; 0000003eH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002a	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 197  : 	MotorData mData;
; 198  : 	int temp;
; 199  : 
; 200  : 	mData.on_off = encodedMData & 1;

  0002d	8b 45 0c	 mov	 eax, DWORD PTR _encodedMData$[ebp]
  00030	83 e0 01	 and	 eax, 1
  00033	88 45 d8	 mov	 BYTE PTR _mData$[ebp], al

; 201  : 	temp = (encodedMData & (3 << 1)) >> 1;

  00036	8b 45 0c	 mov	 eax, DWORD PTR _encodedMData$[ebp]
  00039	83 e0 06	 and	 eax, 6
  0003c	d1 e8		 shr	 eax, 1
  0003e	89 45 cc	 mov	 DWORD PTR _temp$[ebp], eax

; 202  : 
; 203  : 	if (temp == 1) {

  00041	83 7d cc 01	 cmp	 DWORD PTR _temp$[ebp], 1
  00045	75 09		 jne	 SHORT $LN2@unmarshal

; 204  : 		mData.direction = REVERSE;

  00047	c7 45 dc 02 00
	00 00		 mov	 DWORD PTR _mData$[ebp+4], 2
  0004e	eb 16		 jmp	 SHORT $LN3@unmarshal
$LN2@unmarshal:

; 205  : 	}
; 206  : 	else if (temp == 2) {

  00050	83 7d cc 02	 cmp	 DWORD PTR _temp$[ebp], 2
  00054	75 09		 jne	 SHORT $LN4@unmarshal

; 207  : 		mData.direction = FORWARD;

  00056	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _mData$[ebp+4], 1

; 208  : 	}
; 209  : 	else {

  0005d	eb 07		 jmp	 SHORT $LN3@unmarshal
$LN4@unmarshal:

; 210  : 		mData.direction = NO_DIRECTION;

  0005f	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _mData$[ebp+4], 0
$LN3@unmarshal:

; 211  : 	}
; 212  : 
; 213  : 	mData.speed = (encodedMData & (31 << 3)) >> 3;

  00066	8b 45 0c	 mov	 eax, DWORD PTR _encodedMData$[ebp]
  00069	25 f8 00 00 00	 and	 eax, 248		; 000000f8H
  0006e	c1 e8 03	 shr	 eax, 3
  00071	89 45 e0	 mov	 DWORD PTR _mData$[ebp+8], eax

; 214  : 	mData.errorStatus = (encodedMData & (1 << 8));

  00074	8b 45 0c	 mov	 eax, DWORD PTR _encodedMData$[ebp]
  00077	25 00 01 00 00	 and	 eax, 256		; 00000100H
  0007c	88 45 e4	 mov	 BYTE PTR _mData$[ebp+12], al

; 215  : 	mData.noPowerError = (encodedMData & (1 << 9));

  0007f	8b 45 0c	 mov	 eax, DWORD PTR _encodedMData$[ebp]
  00082	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00087	88 45 e5	 mov	 BYTE PTR _mData$[ebp+13], al

; 216  : 	mData.noTorqueError = (encodedMData & (1 << 10));

  0008a	8b 45 0c	 mov	 eax, DWORD PTR _encodedMData$[ebp]
  0008d	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  00092	88 45 e6	 mov	 BYTE PTR _mData$[ebp+14], al

; 217  : 	mData.BITError = (encodedMData & (1 << 11));

  00095	8b 45 0c	 mov	 eax, DWORD PTR _encodedMData$[ebp]
  00098	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  0009d	88 45 e7	 mov	 BYTE PTR _mData$[ebp+15], al

; 218  : 	mData.overTemperatureError = (encodedMData & (1 << 12));

  000a0	8b 45 0c	 mov	 eax, DWORD PTR _encodedMData$[ebp]
  000a3	25 00 10 00 00	 and	 eax, 4096		; 00001000H
  000a8	88 45 e8	 mov	 BYTE PTR _mData$[ebp+16], al

; 219  : 	mData.reservedError1 = (encodedMData & (1 << 13));

  000ab	8b 45 0c	 mov	 eax, DWORD PTR _encodedMData$[ebp]
  000ae	25 00 20 00 00	 and	 eax, 8192		; 00002000H
  000b3	88 45 e9	 mov	 BYTE PTR _mData$[ebp+17], al

; 220  : 	mData.reservedError2 = (encodedMData & (1 << 14));

  000b6	8b 45 0c	 mov	 eax, DWORD PTR _encodedMData$[ebp]
  000b9	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  000be	88 45 ea	 mov	 BYTE PTR _mData$[ebp+18], al

; 221  : 	mData.unknownError = (encodedMData & (1 << 15));

  000c1	8b 45 0c	 mov	 eax, DWORD PTR _encodedMData$[ebp]
  000c4	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  000c9	88 45 eb	 mov	 BYTE PTR _mData$[ebp+19], al

; 222  : 
; 223  : 	return mData;

  000cc	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000cf	8b 4d d8	 mov	 ecx, DWORD PTR _mData$[ebp]
  000d2	89 08		 mov	 DWORD PTR [eax], ecx
  000d4	8b 55 dc	 mov	 edx, DWORD PTR _mData$[ebp+4]
  000d7	89 50 04	 mov	 DWORD PTR [eax+4], edx
  000da	8b 4d e0	 mov	 ecx, DWORD PTR _mData$[ebp+8]
  000dd	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  000e0	8b 55 e4	 mov	 edx, DWORD PTR _mData$[ebp+12]
  000e3	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  000e6	8b 4d e8	 mov	 ecx, DWORD PTR _mData$[ebp+16]
  000e9	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  000ec	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 224  : }

  000ef	52		 push	 edx
  000f0	8b cd		 mov	 ecx, ebp
  000f2	50		 push	 eax
  000f3	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN9@unmarshal
  000f9	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000fe	58		 pop	 eax
  000ff	5a		 pop	 edx
  00100	5f		 pop	 edi
  00101	5e		 pop	 esi
  00102	5b		 pop	 ebx
  00103	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00106	33 cd		 xor	 ecx, ebp
  00108	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010d	8b e5		 mov	 esp, ebp
  0010f	5d		 pop	 ebp
  00110	c2 08 00	 ret	 8
  00113	90		 npad	 1
$LN9@unmarshal:
  00114	01 00 00 00	 DD	 1
  00118	00 00 00 00	 DD	 $LN8@unmarshal
$LN8@unmarshal:
  0011c	d8 ff ff ff	 DD	 -40			; ffffffd8H
  00120	14 00 00 00	 DD	 20			; 00000014H
  00124	00 00 00 00	 DD	 $LN7@unmarshal
$LN7@unmarshal:
  00128	6d		 DB	 109			; 0000006dH
  00129	44		 DB	 68			; 00000044H
  0012a	61		 DB	 97			; 00000061H
  0012b	74		 DB	 116			; 00000074H
  0012c	61		 DB	 97			; 00000061H
  0012d	00		 DB	 0
?unmarshal@MotorProxy@@AAE?AUMotorData@@I@Z ENDP	; MotorProxy::unmarshal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\tim\school\level 6\ci6300 individual project\code\patterns\hardwarepatterns\hardwareproxypatterncpp\motorproxy.cpp
;	COMDAT ?marshal@MotorProxy@@AAEIABUMotorData@@@Z
_TEXT	SEGMENT
_deviceCmd$ = -20					; size = 4
_this$ = -8						; size = 4
_mData$ = 8						; size = 4
?marshal@MotorProxy@@AAEIABUMotorData@@@Z PROC		; MotorProxy::marshal, COMDAT
; _this$ = ecx

; 140  : std::uint32_t MotorProxy::marshal(const MotorData& mData) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 141  : 	std::uint32_t deviceCmd;
; 142  : 
; 143  : 	deviceCmd = 0;

  00023	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _deviceCmd$[ebp], 0

; 144  : 	if (mData.on_off) {

  0002a	8b 45 08	 mov	 eax, DWORD PTR _mData$[ebp]
  0002d	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00030	85 c9		 test	 ecx, ecx
  00032	74 09		 je	 SHORT $LN2@marshal

; 145  : 		deviceCmd |= 1;

  00034	8b 45 ec	 mov	 eax, DWORD PTR _deviceCmd$[ebp]
  00037	83 c8 01	 or	 eax, 1
  0003a	89 45 ec	 mov	 DWORD PTR _deviceCmd$[ebp], eax
$LN2@marshal:

; 146  : 	}
; 147  : 
; 148  : 	if (mData.direction == FORWARD) {

  0003d	8b 45 08	 mov	 eax, DWORD PTR _mData$[ebp]
  00040	83 78 04 01	 cmp	 DWORD PTR [eax+4], 1
  00044	75 0b		 jne	 SHORT $LN3@marshal

; 149  : 		deviceCmd |= (1 << 2);

  00046	8b 45 ec	 mov	 eax, DWORD PTR _deviceCmd$[ebp]
  00049	83 c8 04	 or	 eax, 4
  0004c	89 45 ec	 mov	 DWORD PTR _deviceCmd$[ebp], eax
  0004f	eb 12		 jmp	 SHORT $LN4@marshal
$LN3@marshal:

; 150  : 	}
; 151  : 	else if (mData.direction == REVERSE) {

  00051	8b 45 08	 mov	 eax, DWORD PTR _mData$[ebp]
  00054	83 78 04 02	 cmp	 DWORD PTR [eax+4], 2
  00058	75 09		 jne	 SHORT $LN4@marshal

; 152  : 		deviceCmd |= (1 << 1);

  0005a	8b 45 ec	 mov	 eax, DWORD PTR _deviceCmd$[ebp]
  0005d	83 c8 02	 or	 eax, 2
  00060	89 45 ec	 mov	 DWORD PTR _deviceCmd$[ebp], eax
$LN4@marshal:

; 153  : 	}
; 154  : 
; 155  : 	if (mData.speed < 32 && mData.speed >= 0) {

  00063	8b 45 08	 mov	 eax, DWORD PTR _mData$[ebp]
  00066	83 78 08 20	 cmp	 DWORD PTR [eax+8], 32	; 00000020H
  0006a	73 18		 jae	 SHORT $LN6@marshal
  0006c	8b 45 08	 mov	 eax, DWORD PTR _mData$[ebp]
  0006f	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00073	72 0f		 jb	 SHORT $LN6@marshal

; 156  : 		deviceCmd |= (mData.speed << 3);

  00075	8b 45 08	 mov	 eax, DWORD PTR _mData$[ebp]
  00078	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0007b	c1 e1 03	 shl	 ecx, 3
  0007e	0b 4d ec	 or	 ecx, DWORD PTR _deviceCmd$[ebp]
  00081	89 4d ec	 mov	 DWORD PTR _deviceCmd$[ebp], ecx
$LN6@marshal:

; 157  : 	}
; 158  : 
; 159  : 	if (mData.errorStatus) {

  00084	8b 45 08	 mov	 eax, DWORD PTR _mData$[ebp]
  00087	0f b6 48 0c	 movzx	 ecx, BYTE PTR [eax+12]
  0008b	85 c9		 test	 ecx, ecx
  0008d	74 0b		 je	 SHORT $LN7@marshal

; 160  : 		deviceCmd |= (1 << 8);

  0008f	8b 45 ec	 mov	 eax, DWORD PTR _deviceCmd$[ebp]
  00092	0d 00 01 00 00	 or	 eax, 256		; 00000100H
  00097	89 45 ec	 mov	 DWORD PTR _deviceCmd$[ebp], eax
$LN7@marshal:

; 161  : 	}
; 162  : 
; 163  : 	if (mData.noPowerError) {

  0009a	8b 45 08	 mov	 eax, DWORD PTR _mData$[ebp]
  0009d	0f b6 48 0d	 movzx	 ecx, BYTE PTR [eax+13]
  000a1	85 c9		 test	 ecx, ecx
  000a3	74 0b		 je	 SHORT $LN8@marshal

; 164  : 		deviceCmd |= (1 << 9);

  000a5	8b 45 ec	 mov	 eax, DWORD PTR _deviceCmd$[ebp]
  000a8	0d 00 02 00 00	 or	 eax, 512		; 00000200H
  000ad	89 45 ec	 mov	 DWORD PTR _deviceCmd$[ebp], eax
$LN8@marshal:

; 165  : 	}
; 166  : 
; 167  : 	if (mData.noTorqueError) {

  000b0	8b 45 08	 mov	 eax, DWORD PTR _mData$[ebp]
  000b3	0f b6 48 0e	 movzx	 ecx, BYTE PTR [eax+14]
  000b7	85 c9		 test	 ecx, ecx
  000b9	74 0b		 je	 SHORT $LN9@marshal

; 168  : 		deviceCmd |= (1 << 10);

  000bb	8b 45 ec	 mov	 eax, DWORD PTR _deviceCmd$[ebp]
  000be	0d 00 04 00 00	 or	 eax, 1024		; 00000400H
  000c3	89 45 ec	 mov	 DWORD PTR _deviceCmd$[ebp], eax
$LN9@marshal:

; 169  : 	}
; 170  : 
; 171  : 	if (mData.BITError) {

  000c6	8b 45 08	 mov	 eax, DWORD PTR _mData$[ebp]
  000c9	0f b6 48 0f	 movzx	 ecx, BYTE PTR [eax+15]
  000cd	85 c9		 test	 ecx, ecx
  000cf	74 0b		 je	 SHORT $LN10@marshal

; 172  : 		deviceCmd |= (1 << 11);

  000d1	8b 45 ec	 mov	 eax, DWORD PTR _deviceCmd$[ebp]
  000d4	0d 00 08 00 00	 or	 eax, 2048		; 00000800H
  000d9	89 45 ec	 mov	 DWORD PTR _deviceCmd$[ebp], eax
$LN10@marshal:

; 173  : 	}
; 174  : 
; 175  : 	if (mData.overTemperatureError) {

  000dc	8b 45 08	 mov	 eax, DWORD PTR _mData$[ebp]
  000df	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  000e3	85 c9		 test	 ecx, ecx
  000e5	74 0b		 je	 SHORT $LN11@marshal

; 176  : 		deviceCmd |= (1 << 12);

  000e7	8b 45 ec	 mov	 eax, DWORD PTR _deviceCmd$[ebp]
  000ea	0d 00 10 00 00	 or	 eax, 4096		; 00001000H
  000ef	89 45 ec	 mov	 DWORD PTR _deviceCmd$[ebp], eax
$LN11@marshal:

; 177  : 	}
; 178  : 
; 179  : 	if (mData.reservedError1) {

  000f2	8b 45 08	 mov	 eax, DWORD PTR _mData$[ebp]
  000f5	0f b6 48 11	 movzx	 ecx, BYTE PTR [eax+17]
  000f9	85 c9		 test	 ecx, ecx
  000fb	74 0b		 je	 SHORT $LN12@marshal

; 180  : 		deviceCmd |= (1 << 13);

  000fd	8b 45 ec	 mov	 eax, DWORD PTR _deviceCmd$[ebp]
  00100	0d 00 20 00 00	 or	 eax, 8192		; 00002000H
  00105	89 45 ec	 mov	 DWORD PTR _deviceCmd$[ebp], eax
$LN12@marshal:

; 181  : 	}
; 182  : 
; 183  : 	if (mData.reservedError2) {

  00108	8b 45 08	 mov	 eax, DWORD PTR _mData$[ebp]
  0010b	0f b6 48 12	 movzx	 ecx, BYTE PTR [eax+18]
  0010f	85 c9		 test	 ecx, ecx
  00111	74 0b		 je	 SHORT $LN13@marshal

; 184  : 		deviceCmd |= (1 << 14);

  00113	8b 45 ec	 mov	 eax, DWORD PTR _deviceCmd$[ebp]
  00116	0d 00 40 00 00	 or	 eax, 16384		; 00004000H
  0011b	89 45 ec	 mov	 DWORD PTR _deviceCmd$[ebp], eax
$LN13@marshal:

; 185  : 	}
; 186  : 
; 187  : 	if (mData.unknownError) {

  0011e	8b 45 08	 mov	 eax, DWORD PTR _mData$[ebp]
  00121	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  00125	85 c9		 test	 ecx, ecx
  00127	74 0b		 je	 SHORT $LN14@marshal

; 188  : 		deviceCmd |= (1 << 15);

  00129	8b 45 ec	 mov	 eax, DWORD PTR _deviceCmd$[ebp]
  0012c	0d 00 80 00 00	 or	 eax, 32768		; 00008000H
  00131	89 45 ec	 mov	 DWORD PTR _deviceCmd$[ebp], eax
$LN14@marshal:

; 189  : 	}
; 190  : 
; 191  : 	return deviceCmd;

  00134	8b 45 ec	 mov	 eax, DWORD PTR _deviceCmd$[ebp]

; 192  : }

  00137	5f		 pop	 edi
  00138	5e		 pop	 esi
  00139	5b		 pop	 ebx
  0013a	8b e5		 mov	 esp, ebp
  0013c	5d		 pop	 ebp
  0013d	c2 04 00	 ret	 4
?marshal@MotorProxy@@AAEIABUMotorData@@@Z ENDP		; MotorProxy::marshal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\tim\school\level 6\ci6300 individual project\code\patterns\hardwarepatterns\hardwareproxypatterncpp\motorproxy.cpp
;	COMDAT ?enable@MotorProxy@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?enable@MotorProxy@@QAEXXZ PROC				; MotorProxy::enable, COMDAT
; _this$ = ecx

; 75   : void MotorProxy::enable() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 76   : 	if (this->motorAddr == nullptr) {

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 38 00	 cmp	 DWORD PTR [eax], 0
  00029	75 02		 jne	 SHORT $LN2@enable

; 77   : 		return;

  0002b	eb 11		 jmp	 SHORT $LN1@enable
$LN2@enable:

; 78   : 	}
; 79   : 
; 80   : 	*this->motorAddr |= 1;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	8b 11		 mov	 edx, DWORD PTR [ecx]
  00034	83 ca 01	 or	 edx, 1
  00037	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003c	89 11		 mov	 DWORD PTR [ecx], edx
$LN1@enable:

; 81   : }

  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
?enable@MotorProxy@@QAEXXZ ENDP				; MotorProxy::enable
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\tim\school\level 6\ci6300 individual project\code\patterns\hardwarepatterns\hardwareproxypatterncpp\motorproxy.cpp
;	COMDAT ?disable@MotorProxy@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?disable@MotorProxy@@QAEXXZ PROC			; MotorProxy::disable, COMDAT
; _this$ = ecx

; 65   : void MotorProxy::disable() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 66   : 	if (this->motorAddr == nullptr) {

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 38 00	 cmp	 DWORD PTR [eax], 0
  00029	75 02		 jne	 SHORT $LN2@disable

; 67   : 		return;

  0002b	eb 14		 jmp	 SHORT $LN1@disable
$LN2@disable:

; 68   : 	}
; 69   : 
; 70   : 	*this->motorAddr &= 0xFFFE;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	8b 11		 mov	 edx, DWORD PTR [ecx]
  00034	81 e2 fe ff 00
	00		 and	 edx, 65534		; 0000fffeH
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003f	89 11		 mov	 DWORD PTR [ecx], edx
$LN1@disable:

; 71   : }

  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	5b		 pop	 ebx
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?disable@MotorProxy@@QAEXXZ ENDP			; MotorProxy::disable
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\tim\school\level 6\ci6300 individual project\code\patterns\hardwarepatterns\hardwareproxypatterncpp\motorproxy.cpp
;	COMDAT ?clearErrorStatus@MotorProxy@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?clearErrorStatus@MotorProxy@@QAEXXZ PROC		; MotorProxy::clearErrorStatus, COMDAT
; _this$ = ecx

; 47   : void MotorProxy::clearErrorStatus() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 48   : 	if (this->motorAddr == nullptr) {

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 38 00	 cmp	 DWORD PTR [eax], 0
  00029	75 02		 jne	 SHORT $LN2@clearError

; 49   : 		return;

  0002b	eb 14		 jmp	 SHORT $LN1@clearError
$LN2@clearError:

; 50   : 	}
; 51   : 
; 52   : 	*this->motorAddr &= 0xFF;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	8b 11		 mov	 edx, DWORD PTR [ecx]
  00034	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003f	89 11		 mov	 DWORD PTR [ecx], edx
$LN1@clearError:

; 53   : }

  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	5b		 pop	 ebx
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?clearErrorStatus@MotorProxy@@QAEXXZ ENDP		; MotorProxy::clearErrorStatus
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\tim\school\level 6\ci6300 individual project\code\patterns\hardwarepatterns\hardwareproxypatterncpp\motorproxy.cpp
;	COMDAT ?setMotorSpeed@MotorProxy@@QAEXW4DirectionType@@I@Z
_TEXT	SEGMENT
tv145 = -332						; size = 4
tv139 = -332						; size = 4
$T1 = -324						; size = 20
_dAdjSpeed$ = -104					; size = 8
_dSpeed$ = -88						; size = 8
_dArmLength$ = -72					; size = 8
_mData$ = -40						; size = 20
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_direction$ = 8						; size = 4
_speed$ = 12						; size = 4
?setMotorSpeed@MotorProxy@@QAEXW4DirectionType@@I@Z PROC ; MotorProxy::setMotorSpeed, COMDAT
; _this$ = ecx

; 110  : 	std::uint32_t speed) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 4c 01 00
	00		 sub	 esp, 332		; 0000014cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd b4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-332]
  00013	b9 53 00 00 00	 mov	 ecx, 83			; 00000053H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002a	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 111  : 	MotorData mData;
; 112  : 
; 113  : 	double dPi;
; 114  : 	double dArmLength;
; 115  : 	double dSpeed;
; 116  : 	double dAdjSpeed;
; 117  : 
; 118  : 	if (this->motorAddr == nullptr) {

  0002d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 38 00	 cmp	 DWORD PTR [eax], 0
  00033	75 05		 jne	 SHORT $LN2@setMotorSp

; 119  : 		return;

  00035	e9 e4 00 00 00	 jmp	 $LN1@setMotorSp
$LN2@setMotorSp:

; 120  : 	}
; 121  : 
; 122  : 	mData = unmarshal(*this->motorAddr);

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00041	52		 push	 edx
  00042	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00048	50		 push	 eax
  00049	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?unmarshal@MotorProxy@@AAE?AUMotorData@@I@Z ; MotorProxy::unmarshal
  00051	8b 08		 mov	 ecx, DWORD PTR [eax]
  00053	89 4d d8	 mov	 DWORD PTR _mData$[ebp], ecx
  00056	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00059	89 55 dc	 mov	 DWORD PTR _mData$[ebp+4], edx
  0005c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005f	89 4d e0	 mov	 DWORD PTR _mData$[ebp+8], ecx
  00062	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00065	89 55 e4	 mov	 DWORD PTR _mData$[ebp+12], edx
  00068	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0006b	89 45 e8	 mov	 DWORD PTR _mData$[ebp+16], eax

; 123  : 	mData.direction = direction;

  0006e	8b 45 08	 mov	 eax, DWORD PTR _direction$[ebp]
  00071	89 45 dc	 mov	 DWORD PTR _mData$[ebp+4], eax

; 124  : 
; 125  : 	if (this->rotaryArmLength > 0) {

  00074	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00077	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0007b	0f 86 84 00 00
	00		 jbe	 $LN3@setMotorSp

; 126  : 		dSpeed = speed;

  00081	8b 45 0c	 mov	 eax, DWORD PTR _speed$[ebp]
  00084	89 85 b4 fe ff
	ff		 mov	 DWORD PTR tv139[ebp], eax
  0008a	f2 0f 2a 85 b4
	fe ff ff	 cvtsi2sd xmm0, DWORD PTR tv139[ebp]
  00092	8b 8d b4 fe ff
	ff		 mov	 ecx, DWORD PTR tv139[ebp]
  00098	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0009b	f2 0f 58 04 cd
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
  000a4	f2 0f 11 45 a8	 movsd	 QWORD PTR _dSpeed$[ebp], xmm0

; 127  : 		dArmLength = this->rotaryArmLength;

  000a9	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000ac	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000af	89 8d b4 fe ff
	ff		 mov	 DWORD PTR tv145[ebp], ecx
  000b5	f2 0f 2a 85 b4
	fe ff ff	 cvtsi2sd xmm0, DWORD PTR tv145[ebp]
  000bd	8b 95 b4 fe ff
	ff		 mov	 edx, DWORD PTR tv145[ebp]
  000c3	c1 ea 1f	 shr	 edx, 31			; 0000001fH
  000c6	f2 0f 58 04 d5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
  000cf	f2 0f 11 45 b8	 movsd	 QWORD PTR _dArmLength$[ebp], xmm0

; 128  : 		dAdjSpeed = dSpeed / 2.0 / 3.14159 / dArmLength * 10.0;

  000d4	f2 0f 10 45 a8	 movsd	 xmm0, QWORD PTR _dSpeed$[ebp]
  000d9	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4000000000000000
  000e1	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@400921f9f01b866e
  000e9	f2 0f 5e 45 b8	 divsd	 xmm0, QWORD PTR _dArmLength$[ebp]
  000ee	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4024000000000000
  000f6	f2 0f 11 45 98	 movsd	 QWORD PTR _dAdjSpeed$[ebp], xmm0

; 129  : 		mData.speed = (int)dAdjSpeed;

  000fb	f2 0f 2c 45 98	 cvttsd2si eax, QWORD PTR _dAdjSpeed$[ebp]
  00100	89 45 e0	 mov	 DWORD PTR _mData$[ebp+8], eax

; 130  : 	}
; 131  : 	else {

  00103	eb 06		 jmp	 SHORT $LN4@setMotorSp
$LN3@setMotorSp:

; 132  : 		mData.speed = speed;

  00105	8b 45 0c	 mov	 eax, DWORD PTR _speed$[ebp]
  00108	89 45 e0	 mov	 DWORD PTR _mData$[ebp+8], eax
$LN4@setMotorSp:

; 133  : 	}
; 134  : 
; 135  : 	*this->motorAddr = marshal(mData);

  0010b	8d 45 d8	 lea	 eax, DWORD PTR _mData$[ebp]
  0010e	50		 push	 eax
  0010f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00112	e8 00 00 00 00	 call	 ?marshal@MotorProxy@@AAEIABUMotorData@@@Z ; MotorProxy::marshal
  00117	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0011a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0011c	89 02		 mov	 DWORD PTR [edx], eax
$LN1@setMotorSp:

; 136  : }

  0011e	52		 push	 edx
  0011f	8b cd		 mov	 ecx, ebp
  00121	50		 push	 eax
  00122	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@setMotorSp
  00128	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0012d	58		 pop	 eax
  0012e	5a		 pop	 edx
  0012f	5f		 pop	 edi
  00130	5e		 pop	 esi
  00131	5b		 pop	 ebx
  00132	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00135	33 cd		 xor	 ecx, ebp
  00137	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013c	81 c4 4c 01 00
	00		 add	 esp, 332		; 0000014cH
  00142	3b ec		 cmp	 ebp, esp
  00144	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00149	8b e5		 mov	 esp, ebp
  0014b	5d		 pop	 ebp
  0014c	c2 08 00	 ret	 8
  0014f	90		 npad	 1
$LN8@setMotorSp:
  00150	01 00 00 00	 DD	 1
  00154	00 00 00 00	 DD	 $LN7@setMotorSp
$LN7@setMotorSp:
  00158	d8 ff ff ff	 DD	 -40			; ffffffd8H
  0015c	14 00 00 00	 DD	 20			; 00000014H
  00160	00 00 00 00	 DD	 $LN6@setMotorSp
$LN6@setMotorSp:
  00164	6d		 DB	 109			; 0000006dH
  00165	44		 DB	 68			; 00000044H
  00166	61		 DB	 97			; 00000061H
  00167	74		 DB	 116			; 00000074H
  00168	61		 DB	 97			; 00000061H
  00169	00		 DB	 0
?setMotorSpeed@MotorProxy@@QAEXW4DirectionType@@I@Z ENDP ; MotorProxy::setMotorSpeed
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\tim\school\level 6\ci6300 individual project\code\patterns\hardwarepatterns\hardwareproxypatterncpp\motorproxy.cpp
;	COMDAT ?getMotorState@MotorProxy@@QAEIXZ
_TEXT	SEGMENT
$T1 = -260						; size = 20
_mData$ = -40						; size = 20
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?getMotorState@MotorProxy@@QAEIXZ PROC			; MotorProxy::getMotorState, COMDAT
; _this$ = ecx

; 33   : std::uint32_t MotorProxy::getMotorState() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-264]
  00013	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002a	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 34   : 	MotorData mData;
; 35   : 
; 36   : 	if (this->motorAddr == nullptr) {

  0002d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 38 00	 cmp	 DWORD PTR [eax], 0
  00033	75 04		 jne	 SHORT $LN2@getMotorSt

; 37   : 		return 0;

  00035	33 c0		 xor	 eax, eax
  00037	eb 38		 jmp	 SHORT $LN1@getMotorSt
$LN2@getMotorSt:

; 38   : 	}
; 39   : 
; 40   : 	mData = unmarshal(*this->motorAddr);

  00039	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00040	52		 push	 edx
  00041	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00047	50		 push	 eax
  00048	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	e8 00 00 00 00	 call	 ?unmarshal@MotorProxy@@AAE?AUMotorData@@I@Z ; MotorProxy::unmarshal
  00050	8b 08		 mov	 ecx, DWORD PTR [eax]
  00052	89 4d d8	 mov	 DWORD PTR _mData$[ebp], ecx
  00055	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00058	89 55 dc	 mov	 DWORD PTR _mData$[ebp+4], edx
  0005b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005e	89 4d e0	 mov	 DWORD PTR _mData$[ebp+8], ecx
  00061	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00064	89 55 e4	 mov	 DWORD PTR _mData$[ebp+12], edx
  00067	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0006a	89 45 e8	 mov	 DWORD PTR _mData$[ebp+16], eax

; 41   : 
; 42   : 	return mData.errorStatus;

  0006d	0f b6 45 e4	 movzx	 eax, BYTE PTR _mData$[ebp+12]
$LN1@getMotorSt:

; 43   : }

  00071	52		 push	 edx
  00072	8b cd		 mov	 ecx, ebp
  00074	50		 push	 eax
  00075	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@getMotorSt
  0007b	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00080	58		 pop	 eax
  00081	5a		 pop	 edx
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx
  00085	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00088	33 cd		 xor	 ecx, ebp
  0008a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008f	81 c4 08 01 00
	00		 add	 esp, 264		; 00000108H
  00095	3b ec		 cmp	 ebp, esp
  00097	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
$LN6@getMotorSt:
  000a0	01 00 00 00	 DD	 1
  000a4	00 00 00 00	 DD	 $LN5@getMotorSt
$LN5@getMotorSt:
  000a8	d8 ff ff ff	 DD	 -40			; ffffffd8H
  000ac	14 00 00 00	 DD	 20			; 00000014H
  000b0	00 00 00 00	 DD	 $LN4@getMotorSt
$LN4@getMotorSt:
  000b4	6d		 DB	 109			; 0000006dH
  000b5	44		 DB	 68			; 00000044H
  000b6	61		 DB	 97			; 00000061H
  000b7	74		 DB	 116			; 00000074H
  000b8	61		 DB	 97			; 00000061H
  000b9	00		 DB	 0
?getMotorState@MotorProxy@@QAEIXZ ENDP			; MotorProxy::getMotorState
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\tim\school\level 6\ci6300 individual project\code\patterns\hardwarepatterns\hardwareproxypatterncpp\motorproxy.cpp
;	COMDAT ?getMotorSpeed@MotorProxy@@QAEIXZ
_TEXT	SEGMENT
$T1 = -260						; size = 20
_mData$ = -40						; size = 20
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?getMotorSpeed@MotorProxy@@QAEIXZ PROC			; MotorProxy::getMotorSpeed, COMDAT
; _this$ = ecx

; 19   : std::uint32_t MotorProxy::getMotorSpeed() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-264]
  00013	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002a	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 20   : 	MotorData mData;
; 21   : 
; 22   : 	if (this->motorAddr == nullptr) {

  0002d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 38 00	 cmp	 DWORD PTR [eax], 0
  00033	75 04		 jne	 SHORT $LN2@getMotorSp

; 23   : 		return 0;

  00035	33 c0		 xor	 eax, eax
  00037	eb 37		 jmp	 SHORT $LN1@getMotorSp
$LN2@getMotorSp:

; 24   : 	}
; 25   : 
; 26   : 	mData = unmarshal(*this->motorAddr);

  00039	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00040	52		 push	 edx
  00041	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00047	50		 push	 eax
  00048	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	e8 00 00 00 00	 call	 ?unmarshal@MotorProxy@@AAE?AUMotorData@@I@Z ; MotorProxy::unmarshal
  00050	8b 08		 mov	 ecx, DWORD PTR [eax]
  00052	89 4d d8	 mov	 DWORD PTR _mData$[ebp], ecx
  00055	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00058	89 55 dc	 mov	 DWORD PTR _mData$[ebp+4], edx
  0005b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005e	89 4d e0	 mov	 DWORD PTR _mData$[ebp+8], ecx
  00061	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00064	89 55 e4	 mov	 DWORD PTR _mData$[ebp+12], edx
  00067	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0006a	89 45 e8	 mov	 DWORD PTR _mData$[ebp+16], eax

; 27   : 
; 28   : 	return mData.speed;

  0006d	8b 45 e0	 mov	 eax, DWORD PTR _mData$[ebp+8]
$LN1@getMotorSp:

; 29   : }

  00070	52		 push	 edx
  00071	8b cd		 mov	 ecx, ebp
  00073	50		 push	 eax
  00074	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@getMotorSp
  0007a	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0007f	58		 pop	 eax
  00080	5a		 pop	 edx
  00081	5f		 pop	 edi
  00082	5e		 pop	 esi
  00083	5b		 pop	 ebx
  00084	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00087	33 cd		 xor	 ecx, ebp
  00089	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008e	81 c4 08 01 00
	00		 add	 esp, 264		; 00000108H
  00094	3b ec		 cmp	 ebp, esp
  00096	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c3		 ret	 0
  0009f	90		 npad	 1
$LN6@getMotorSp:
  000a0	01 00 00 00	 DD	 1
  000a4	00 00 00 00	 DD	 $LN5@getMotorSp
$LN5@getMotorSp:
  000a8	d8 ff ff ff	 DD	 -40			; ffffffd8H
  000ac	14 00 00 00	 DD	 20			; 00000014H
  000b0	00 00 00 00	 DD	 $LN4@getMotorSp
$LN4@getMotorSp:
  000b4	6d		 DB	 109			; 0000006dH
  000b5	44		 DB	 68			; 00000044H
  000b6	61		 DB	 97			; 00000061H
  000b7	74		 DB	 116			; 00000074H
  000b8	61		 DB	 97			; 00000061H
  000b9	00		 DB	 0
?getMotorSpeed@MotorProxy@@QAEIXZ ENDP			; MotorProxy::getMotorSpeed
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\tim\school\level 6\ci6300 individual project\code\patterns\hardwarepatterns\hardwareproxypatterncpp\motorproxy.cpp
;	COMDAT ?getMotorDirection@MotorProxy@@QAE?AW4DirectionType@@XZ
_TEXT	SEGMENT
$T1 = -260						; size = 20
_mData$ = -40						; size = 20
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?getMotorDirection@MotorProxy@@QAE?AW4DirectionType@@XZ PROC ; MotorProxy::getMotorDirection, COMDAT
; _this$ = ecx

; 5    : DirectionType MotorProxy::getMotorDirection() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-264]
  00013	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002a	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 6    : 	MotorData mData;
; 7    : 
; 8    : 	if (motorAddr == nullptr) {

  0002d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 38 00	 cmp	 DWORD PTR [eax], 0
  00033	75 04		 jne	 SHORT $LN2@getMotorDi

; 9    : 		return NO_DIRECTION;

  00035	33 c0		 xor	 eax, eax
  00037	eb 37		 jmp	 SHORT $LN1@getMotorDi
$LN2@getMotorDi:

; 10   : 	}
; 11   : 
; 12   : 	mData = unmarshal(*this->motorAddr);

  00039	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00040	52		 push	 edx
  00041	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00047	50		 push	 eax
  00048	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	e8 00 00 00 00	 call	 ?unmarshal@MotorProxy@@AAE?AUMotorData@@I@Z ; MotorProxy::unmarshal
  00050	8b 08		 mov	 ecx, DWORD PTR [eax]
  00052	89 4d d8	 mov	 DWORD PTR _mData$[ebp], ecx
  00055	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00058	89 55 dc	 mov	 DWORD PTR _mData$[ebp+4], edx
  0005b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005e	89 4d e0	 mov	 DWORD PTR _mData$[ebp+8], ecx
  00061	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00064	89 55 e4	 mov	 DWORD PTR _mData$[ebp+12], edx
  00067	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0006a	89 45 e8	 mov	 DWORD PTR _mData$[ebp+16], eax

; 13   : 
; 14   : 	return mData.direction;

  0006d	8b 45 dc	 mov	 eax, DWORD PTR _mData$[ebp+4]
$LN1@getMotorDi:

; 15   : }

  00070	52		 push	 edx
  00071	8b cd		 mov	 ecx, ebp
  00073	50		 push	 eax
  00074	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@getMotorDi
  0007a	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0007f	58		 pop	 eax
  00080	5a		 pop	 edx
  00081	5f		 pop	 edi
  00082	5e		 pop	 esi
  00083	5b		 pop	 ebx
  00084	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00087	33 cd		 xor	 ecx, ebp
  00089	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008e	81 c4 08 01 00
	00		 add	 esp, 264		; 00000108H
  00094	3b ec		 cmp	 ebp, esp
  00096	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c3		 ret	 0
  0009f	90		 npad	 1
$LN6@getMotorDi:
  000a0	01 00 00 00	 DD	 1
  000a4	00 00 00 00	 DD	 $LN5@getMotorDi
$LN5@getMotorDi:
  000a8	d8 ff ff ff	 DD	 -40			; ffffffd8H
  000ac	14 00 00 00	 DD	 20			; 00000014H
  000b0	00 00 00 00	 DD	 $LN4@getMotorDi
$LN4@getMotorDi:
  000b4	6d		 DB	 109			; 0000006dH
  000b5	44		 DB	 68			; 00000044H
  000b6	61		 DB	 97			; 00000061H
  000b7	74		 DB	 116			; 00000074H
  000b8	61		 DB	 97			; 00000061H
  000b9	00		 DB	 0
?getMotorDirection@MotorProxy@@QAE?AW4DirectionType@@XZ ENDP ; MotorProxy::getMotorDirection
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\tim\school\level 6\ci6300 individual project\code\patterns\hardwarepatterns\hardwareproxypatterncpp\motorproxy.cpp
;	COMDAT ?initialize@MotorProxy@@QAEXXZ
_TEXT	SEGMENT
_mData$ = -40						; size = 20
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?initialize@MotorProxy@@QAEXXZ PROC			; MotorProxy::initialize, COMDAT
; _this$ = ecx

; 85   : void MotorProxy::initialize() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ec 00 00
	00		 sub	 esp, 236		; 000000ecH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 14 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-236]
  00013	b9 3b 00 00 00	 mov	 ecx, 59			; 0000003bH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002a	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 86   : 	MotorData mData;
; 87   : 
; 88   : 	if (this->motorAddr == nullptr) {

  0002d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 38 00	 cmp	 DWORD PTR [eax], 0
  00033	75 02		 jne	 SHORT $LN2@initialize

; 89   : 		return;

  00035	eb 45		 jmp	 SHORT $LN1@initialize
$LN2@initialize:

; 90   : 	}
; 91   : 
; 92   : 	mData.on_off = 1;

  00037	c6 45 d8 01	 mov	 BYTE PTR _mData$[ebp], 1

; 93   : 	mData.direction = NO_DIRECTION;

  0003b	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _mData$[ebp+4], 0

; 94   : 	mData.speed = 0;

  00042	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _mData$[ebp+8], 0

; 95   : 	mData.errorStatus = 0;

  00049	c6 45 e4 00	 mov	 BYTE PTR _mData$[ebp+12], 0

; 96   : 	mData.noPowerError = 0;

  0004d	c6 45 e5 00	 mov	 BYTE PTR _mData$[ebp+13], 0

; 97   : 	mData.noTorqueError = 0;

  00051	c6 45 e6 00	 mov	 BYTE PTR _mData$[ebp+14], 0

; 98   : 	mData.BITError = 0;

  00055	c6 45 e7 00	 mov	 BYTE PTR _mData$[ebp+15], 0

; 99   : 	mData.overTemperatureError = 0;

  00059	c6 45 e8 00	 mov	 BYTE PTR _mData$[ebp+16], 0

; 100  : 	mData.reservedError1 = 0;

  0005d	c6 45 e9 00	 mov	 BYTE PTR _mData$[ebp+17], 0

; 101  : 	mData.reservedError2 = 0;

  00061	c6 45 ea 00	 mov	 BYTE PTR _mData$[ebp+18], 0

; 102  : 	mData.unknownError = 0;

  00065	c6 45 eb 00	 mov	 BYTE PTR _mData$[ebp+19], 0

; 103  : 
; 104  : 	*this->motorAddr = marshal(mData);

  00069	8d 45 d8	 lea	 eax, DWORD PTR _mData$[ebp]
  0006c	50		 push	 eax
  0006d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00070	e8 00 00 00 00	 call	 ?marshal@MotorProxy@@AAEIABUMotorData@@@Z ; MotorProxy::marshal
  00075	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007a	89 02		 mov	 DWORD PTR [edx], eax
$LN1@initialize:

; 105  : }

  0007c	52		 push	 edx
  0007d	8b cd		 mov	 ecx, ebp
  0007f	50		 push	 eax
  00080	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@initialize
  00086	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0008b	58		 pop	 eax
  0008c	5a		 pop	 edx
  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	5b		 pop	 ebx
  00090	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00093	33 cd		 xor	 ecx, ebp
  00095	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009a	81 c4 ec 00 00
	00		 add	 esp, 236		; 000000ecH
  000a0	3b ec		 cmp	 ebp, esp
  000a2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c3		 ret	 0
  000ab	90		 npad	 1
$LN6@initialize:
  000ac	01 00 00 00	 DD	 1
  000b0	00 00 00 00	 DD	 $LN5@initialize
$LN5@initialize:
  000b4	d8 ff ff ff	 DD	 -40			; ffffffd8H
  000b8	14 00 00 00	 DD	 20			; 00000014H
  000bc	00 00 00 00	 DD	 $LN4@initialize
$LN4@initialize:
  000c0	6d		 DB	 109			; 0000006dH
  000c1	44		 DB	 68			; 00000044H
  000c2	61		 DB	 97			; 00000061H
  000c3	74		 DB	 116			; 00000074H
  000c4	61		 DB	 97			; 00000061H
  000c5	00		 DB	 0
?initialize@MotorProxy@@QAEXXZ ENDP			; MotorProxy::initialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\tim\school\level 6\ci6300 individual project\code\patterns\hardwarepatterns\hardwareproxypatterncpp\motorproxy.cpp
;	COMDAT ?configure@MotorProxy@@QAEXIPAI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_length$ = 8						; size = 4
_location$ = 12						; size = 4
?configure@MotorProxy@@QAEXIPAI@Z PROC			; MotorProxy::configure, COMDAT
; _this$ = ecx

; 58   : 	std::uint32_t* location) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 59   : 	this->rotaryArmLength = length;

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 4d 08	 mov	 ecx, DWORD PTR _length$[ebp]
  00029	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 60   : 	this->motorAddr = location;

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR _location$[ebp]
  00032	89 08		 mov	 DWORD PTR [eax], ecx

; 61   : }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 08 00	 ret	 8
?configure@MotorProxy@@QAEXIPAI@Z ENDP			; MotorProxy::configure
_TEXT	ENDS
END
