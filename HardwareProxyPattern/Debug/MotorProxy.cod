; Listing generated by Microsoft (R) Optimizing Compiler Version 19.12.25835.0 

	TITLE	C:\Users\Tim\School\Level 6\CI6300 Individual Project\Code\Patterns\HardwarePatterns\HardwareProxyPattern\MotorProxy.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?MotorProxy_Init@@YAXQAUMotorProxy@@@Z		; MotorProxy_Init
PUBLIC	?MotorProxy_Cleanup@@YAXQAUMotorProxy@@@Z	; MotorProxy_Cleanup
PUBLIC	?MotorProxy_accessMotorDirection@@YA?AW4DirectionType@@QAUMotorProxy@@@Z ; MotorProxy_accessMotorDirection
PUBLIC	?MotorProxy_accessMotorSpeed@@YAIQAUMotorProxy@@@Z ; MotorProxy_accessMotorSpeed
PUBLIC	?MotorProxy_accessMotorState@@YAIQAUMotorProxy@@@Z ; MotorProxy_accessMotorState
PUBLIC	?MotorProxy_clearErrorStatus@@YAXQAUMotorProxy@@@Z ; MotorProxy_clearErrorStatus
PUBLIC	?MotorProxy_configure@@YAXQAUMotorProxy@@IPAI@Z	; MotorProxy_configure
PUBLIC	?MotorProxy_initialize@@YAXQAUMotorProxy@@@Z	; MotorProxy_initialize
PUBLIC	?MotorProxy_Create@@YAPAUMotorProxy@@XZ		; MotorProxy_Create
PUBLIC	?MotorProxy_Destroy@@YAXQAUMotorProxy@@@Z	; MotorProxy_Destroy
PUBLIC	?MotorProxy_disable@@YAXQAUMotorProxy@@@Z	; MotorProxy_disable
PUBLIC	?MotorProxy_enable@@YAXQAUMotorProxy@@@Z	; MotorProxy_enable
PUBLIC	?MotorProxy_writeMotorSpeed@@YAXQAUMotorProxy@@W4DirectionType@@I@Z ; MotorProxy_writeMotorSpeed
PUBLIC	__real@4000000000000000
PUBLIC	__real@400921f9f01b866e
PUBLIC	__real@4024000000000000
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@400921f9f01b866e
CONST	SEGMENT
__real@400921f9f01b866e DQ 0400921f9f01b866er	; 3.14159
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\tim\school\level 6\ci6300 individual project\code\patterns\hardwarepatterns\hardwareproxypattern\motorproxy.cpp
;	COMDAT ?unmarshal@@YA?AUMotorData@@I@Z
_TEXT	SEGMENT
_temp$ = -40						; size = 4
_mData$ = -28						; size = 20
__$ArrayPad$ = -4					; size = 4
$T1 = 8							; size = 4
_encodedMData$ = 12					; size = 4
?unmarshal@@YA?AUMotorData@@I@Z PROC			; unmarshal, COMDAT

; 215  : static struct MotorData unmarshal(unsigned int encodedMData) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ec 00 00
	00		 sub	 esp, 236		; 000000ecH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 14 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-236]
  00012	b9 3b 00 00 00	 mov	 ecx, 59			; 0000003bH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 216  : 	MotorData mData;
; 217  : 	int temp;
; 218  : 
; 219  : 	mData.on_off = encodedMData & 1;

  00028	8b 45 0c	 mov	 eax, DWORD PTR _encodedMData$[ebp]
  0002b	83 e0 01	 and	 eax, 1
  0002e	88 45 e4	 mov	 BYTE PTR _mData$[ebp], al

; 220  : 	temp = (encodedMData & (3 << 1)) >> 1;

  00031	8b 45 0c	 mov	 eax, DWORD PTR _encodedMData$[ebp]
  00034	83 e0 06	 and	 eax, 6
  00037	d1 e8		 shr	 eax, 1
  00039	89 45 d8	 mov	 DWORD PTR _temp$[ebp], eax

; 221  : 
; 222  : 	if (temp == 1) {

  0003c	83 7d d8 01	 cmp	 DWORD PTR _temp$[ebp], 1
  00040	75 09		 jne	 SHORT $LN2@unmarshal

; 223  : 		mData.direction = REVERSE;

  00042	c7 45 e8 02 00
	00 00		 mov	 DWORD PTR _mData$[ebp+4], 2
  00049	eb 16		 jmp	 SHORT $LN3@unmarshal
$LN2@unmarshal:

; 224  : 	}
; 225  : 	else if (temp == 2) {

  0004b	83 7d d8 02	 cmp	 DWORD PTR _temp$[ebp], 2
  0004f	75 09		 jne	 SHORT $LN4@unmarshal

; 226  : 		mData.direction = FORWARD;

  00051	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _mData$[ebp+4], 1

; 227  : 	}
; 228  : 	else {

  00058	eb 07		 jmp	 SHORT $LN3@unmarshal
$LN4@unmarshal:

; 229  : 		mData.direction = NO_DIRECTION;

  0005a	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _mData$[ebp+4], 0
$LN3@unmarshal:

; 230  : 	}
; 231  : 
; 232  : 	mData.speed = (encodedMData & (31 << 3)) >> 3;

  00061	8b 45 0c	 mov	 eax, DWORD PTR _encodedMData$[ebp]
  00064	25 f8 00 00 00	 and	 eax, 248		; 000000f8H
  00069	c1 e8 03	 shr	 eax, 3
  0006c	89 45 ec	 mov	 DWORD PTR _mData$[ebp+8], eax

; 233  : 	mData.errorStatus = (encodedMData & (1 << 8));

  0006f	8b 45 0c	 mov	 eax, DWORD PTR _encodedMData$[ebp]
  00072	25 00 01 00 00	 and	 eax, 256		; 00000100H
  00077	88 45 f0	 mov	 BYTE PTR _mData$[ebp+12], al

; 234  : 	mData.noPowerError = (encodedMData & (1 << 9));

  0007a	8b 45 0c	 mov	 eax, DWORD PTR _encodedMData$[ebp]
  0007d	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00082	88 45 f1	 mov	 BYTE PTR _mData$[ebp+13], al

; 235  : 	mData.noTorqueError = (encodedMData & (1 << 10));

  00085	8b 45 0c	 mov	 eax, DWORD PTR _encodedMData$[ebp]
  00088	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  0008d	88 45 f2	 mov	 BYTE PTR _mData$[ebp+14], al

; 236  : 	mData.BITError = (encodedMData & (1 << 11));

  00090	8b 45 0c	 mov	 eax, DWORD PTR _encodedMData$[ebp]
  00093	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  00098	88 45 f3	 mov	 BYTE PTR _mData$[ebp+15], al

; 237  : 	mData.overTemperatureError = (encodedMData & (1 << 12));

  0009b	8b 45 0c	 mov	 eax, DWORD PTR _encodedMData$[ebp]
  0009e	25 00 10 00 00	 and	 eax, 4096		; 00001000H
  000a3	88 45 f4	 mov	 BYTE PTR _mData$[ebp+16], al

; 238  : 	mData.reservedError1 = (encodedMData & (1 << 13));

  000a6	8b 45 0c	 mov	 eax, DWORD PTR _encodedMData$[ebp]
  000a9	25 00 20 00 00	 and	 eax, 8192		; 00002000H
  000ae	88 45 f5	 mov	 BYTE PTR _mData$[ebp+17], al

; 239  : 	mData.reservedError2 = (encodedMData & (1 << 14));

  000b1	8b 45 0c	 mov	 eax, DWORD PTR _encodedMData$[ebp]
  000b4	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  000b9	88 45 f6	 mov	 BYTE PTR _mData$[ebp+18], al

; 240  : 	mData.unknownError = (encodedMData & (1 << 15));

  000bc	8b 45 0c	 mov	 eax, DWORD PTR _encodedMData$[ebp]
  000bf	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  000c4	88 45 f7	 mov	 BYTE PTR _mData$[ebp+19], al

; 241  : 
; 242  : 	return mData;

  000c7	8b 45 08	 mov	 eax, DWORD PTR $T1[ebp]
  000ca	8b 4d e4	 mov	 ecx, DWORD PTR _mData$[ebp]
  000cd	89 08		 mov	 DWORD PTR [eax], ecx
  000cf	8b 55 e8	 mov	 edx, DWORD PTR _mData$[ebp+4]
  000d2	89 50 04	 mov	 DWORD PTR [eax+4], edx
  000d5	8b 4d ec	 mov	 ecx, DWORD PTR _mData$[ebp+8]
  000d8	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  000db	8b 55 f0	 mov	 edx, DWORD PTR _mData$[ebp+12]
  000de	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  000e1	8b 4d f4	 mov	 ecx, DWORD PTR _mData$[ebp+16]
  000e4	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  000e7	8b 45 08	 mov	 eax, DWORD PTR $T1[ebp]

; 243  : }

  000ea	52		 push	 edx
  000eb	8b cd		 mov	 ecx, ebp
  000ed	50		 push	 eax
  000ee	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN9@unmarshal
  000f4	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000f9	58		 pop	 eax
  000fa	5a		 pop	 edx
  000fb	5f		 pop	 edi
  000fc	5e		 pop	 esi
  000fd	5b		 pop	 ebx
  000fe	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00101	33 cd		 xor	 ecx, ebp
  00103	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00108	8b e5		 mov	 esp, ebp
  0010a	5d		 pop	 ebp
  0010b	c3		 ret	 0
$LN9@unmarshal:
  0010c	01 00 00 00	 DD	 1
  00110	00 00 00 00	 DD	 $LN8@unmarshal
$LN8@unmarshal:
  00114	e4 ff ff ff	 DD	 -28			; ffffffe4H
  00118	14 00 00 00	 DD	 20			; 00000014H
  0011c	00 00 00 00	 DD	 $LN7@unmarshal
$LN7@unmarshal:
  00120	6d		 DB	 109			; 0000006dH
  00121	44		 DB	 68			; 00000044H
  00122	61		 DB	 97			; 00000061H
  00123	74		 DB	 116			; 00000074H
  00124	61		 DB	 97			; 00000061H
  00125	00		 DB	 0
?unmarshal@@YA?AUMotorData@@I@Z ENDP			; unmarshal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\tim\school\level 6\ci6300 individual project\code\patterns\hardwarepatterns\hardwareproxypattern\motorproxy.cpp
;	COMDAT ?marshal@@YAIUMotorData@@@Z
_TEXT	SEGMENT
_deviceCmd$ = -8					; size = 4
_mData$ = 8						; size = 20
?marshal@@YAIUMotorData@@@Z PROC			; marshal, COMDAT

; 159  : static unsigned int marshal(const struct MotorData mData) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 160  : 	unsigned int deviceCmd;
; 161  : 
; 162  : 	deviceCmd = 0;

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _deviceCmd$[ebp], 0

; 163  : 	if (mData.on_off) {

  00025	0f b6 45 08	 movzx	 eax, BYTE PTR _mData$[ebp]
  00029	85 c0		 test	 eax, eax
  0002b	74 09		 je	 SHORT $LN2@marshal

; 164  : 		deviceCmd |= 1;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _deviceCmd$[ebp]
  00030	83 c8 01	 or	 eax, 1
  00033	89 45 f8	 mov	 DWORD PTR _deviceCmd$[ebp], eax
$LN2@marshal:

; 165  : 	}
; 166  : 
; 167  : 	if (mData.direction == FORWARD) {

  00036	83 7d 0c 01	 cmp	 DWORD PTR _mData$[ebp+4], 1
  0003a	75 0b		 jne	 SHORT $LN3@marshal

; 168  : 		deviceCmd |= (1 << 2);

  0003c	8b 45 f8	 mov	 eax, DWORD PTR _deviceCmd$[ebp]
  0003f	83 c8 04	 or	 eax, 4
  00042	89 45 f8	 mov	 DWORD PTR _deviceCmd$[ebp], eax
  00045	eb 0f		 jmp	 SHORT $LN4@marshal
$LN3@marshal:

; 169  : 	}
; 170  : 	else if (mData.direction == REVERSE) {

  00047	83 7d 0c 02	 cmp	 DWORD PTR _mData$[ebp+4], 2
  0004b	75 09		 jne	 SHORT $LN4@marshal

; 171  : 		deviceCmd |= (1 << 1);

  0004d	8b 45 f8	 mov	 eax, DWORD PTR _deviceCmd$[ebp]
  00050	83 c8 02	 or	 eax, 2
  00053	89 45 f8	 mov	 DWORD PTR _deviceCmd$[ebp], eax
$LN4@marshal:

; 172  : 	}
; 173  : 
; 174  : 	if (mData.speed < 32 && mData.speed >= 0) {

  00056	83 7d 10 20	 cmp	 DWORD PTR _mData$[ebp+8], 32 ; 00000020H
  0005a	73 12		 jae	 SHORT $LN6@marshal
  0005c	83 7d 10 00	 cmp	 DWORD PTR _mData$[ebp+8], 0
  00060	72 0c		 jb	 SHORT $LN6@marshal

; 175  : 		deviceCmd |= (mData.speed << 3);

  00062	8b 45 10	 mov	 eax, DWORD PTR _mData$[ebp+8]
  00065	c1 e0 03	 shl	 eax, 3
  00068	0b 45 f8	 or	 eax, DWORD PTR _deviceCmd$[ebp]
  0006b	89 45 f8	 mov	 DWORD PTR _deviceCmd$[ebp], eax
$LN6@marshal:

; 176  : 	}
; 177  : 
; 178  : 	if (mData.errorStatus) {

  0006e	0f b6 45 14	 movzx	 eax, BYTE PTR _mData$[ebp+12]
  00072	85 c0		 test	 eax, eax
  00074	74 0b		 je	 SHORT $LN7@marshal

; 179  : 		deviceCmd |= (1 << 8);

  00076	8b 45 f8	 mov	 eax, DWORD PTR _deviceCmd$[ebp]
  00079	0d 00 01 00 00	 or	 eax, 256		; 00000100H
  0007e	89 45 f8	 mov	 DWORD PTR _deviceCmd$[ebp], eax
$LN7@marshal:

; 180  : 	}
; 181  : 
; 182  : 	if (mData.noPowerError) {

  00081	0f b6 45 15	 movzx	 eax, BYTE PTR _mData$[ebp+13]
  00085	85 c0		 test	 eax, eax
  00087	74 0b		 je	 SHORT $LN8@marshal

; 183  : 		deviceCmd |= (1 << 9);

  00089	8b 45 f8	 mov	 eax, DWORD PTR _deviceCmd$[ebp]
  0008c	0d 00 02 00 00	 or	 eax, 512		; 00000200H
  00091	89 45 f8	 mov	 DWORD PTR _deviceCmd$[ebp], eax
$LN8@marshal:

; 184  : 	}
; 185  : 
; 186  : 	if (mData.noTorqueError) {

  00094	0f b6 45 16	 movzx	 eax, BYTE PTR _mData$[ebp+14]
  00098	85 c0		 test	 eax, eax
  0009a	74 0b		 je	 SHORT $LN9@marshal

; 187  : 		deviceCmd |= (1 << 10);

  0009c	8b 45 f8	 mov	 eax, DWORD PTR _deviceCmd$[ebp]
  0009f	0d 00 04 00 00	 or	 eax, 1024		; 00000400H
  000a4	89 45 f8	 mov	 DWORD PTR _deviceCmd$[ebp], eax
$LN9@marshal:

; 188  : 	}
; 189  : 
; 190  : 	if (mData.BITError) {

  000a7	0f b6 45 17	 movzx	 eax, BYTE PTR _mData$[ebp+15]
  000ab	85 c0		 test	 eax, eax
  000ad	74 0b		 je	 SHORT $LN10@marshal

; 191  : 		deviceCmd |= (1 << 11);

  000af	8b 45 f8	 mov	 eax, DWORD PTR _deviceCmd$[ebp]
  000b2	0d 00 08 00 00	 or	 eax, 2048		; 00000800H
  000b7	89 45 f8	 mov	 DWORD PTR _deviceCmd$[ebp], eax
$LN10@marshal:

; 192  : 	}
; 193  : 
; 194  : 	if (mData.overTemperatureError) {

  000ba	0f b6 45 18	 movzx	 eax, BYTE PTR _mData$[ebp+16]
  000be	85 c0		 test	 eax, eax
  000c0	74 0b		 je	 SHORT $LN11@marshal

; 195  : 		deviceCmd |= (1 << 12);

  000c2	8b 45 f8	 mov	 eax, DWORD PTR _deviceCmd$[ebp]
  000c5	0d 00 10 00 00	 or	 eax, 4096		; 00001000H
  000ca	89 45 f8	 mov	 DWORD PTR _deviceCmd$[ebp], eax
$LN11@marshal:

; 196  : 	}
; 197  : 
; 198  : 	if (mData.reservedError1) {

  000cd	0f b6 45 19	 movzx	 eax, BYTE PTR _mData$[ebp+17]
  000d1	85 c0		 test	 eax, eax
  000d3	74 0b		 je	 SHORT $LN12@marshal

; 199  : 		deviceCmd |= (1 << 13);

  000d5	8b 45 f8	 mov	 eax, DWORD PTR _deviceCmd$[ebp]
  000d8	0d 00 20 00 00	 or	 eax, 8192		; 00002000H
  000dd	89 45 f8	 mov	 DWORD PTR _deviceCmd$[ebp], eax
$LN12@marshal:

; 200  : 	}
; 201  : 
; 202  : 	if (mData.reservedError2) {

  000e0	0f b6 45 1a	 movzx	 eax, BYTE PTR _mData$[ebp+18]
  000e4	85 c0		 test	 eax, eax
  000e6	74 0b		 je	 SHORT $LN13@marshal

; 203  : 		deviceCmd |= (1 << 14);

  000e8	8b 45 f8	 mov	 eax, DWORD PTR _deviceCmd$[ebp]
  000eb	0d 00 40 00 00	 or	 eax, 16384		; 00004000H
  000f0	89 45 f8	 mov	 DWORD PTR _deviceCmd$[ebp], eax
$LN13@marshal:

; 204  : 	}
; 205  : 
; 206  : 	if (mData.unknownError) {

  000f3	0f b6 45 1b	 movzx	 eax, BYTE PTR _mData$[ebp+19]
  000f7	85 c0		 test	 eax, eax
  000f9	74 0b		 je	 SHORT $LN14@marshal

; 207  : 		deviceCmd |= (1 << 15);

  000fb	8b 45 f8	 mov	 eax, DWORD PTR _deviceCmd$[ebp]
  000fe	0d 00 80 00 00	 or	 eax, 32768		; 00008000H
  00103	89 45 f8	 mov	 DWORD PTR _deviceCmd$[ebp], eax
$LN14@marshal:

; 208  : 	}
; 209  : 
; 210  : 	return deviceCmd;

  00106	8b 45 f8	 mov	 eax, DWORD PTR _deviceCmd$[ebp]

; 211  : }

  00109	5f		 pop	 edi
  0010a	5e		 pop	 esi
  0010b	5b		 pop	 ebx
  0010c	8b e5		 mov	 esp, ebp
  0010e	5d		 pop	 ebp
  0010f	c3		 ret	 0
?marshal@@YAIUMotorData@@@Z ENDP			; marshal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\tim\school\level 6\ci6300 individual project\code\patterns\hardwarepatterns\hardwareproxypattern\motorproxy.cpp
;	COMDAT ?MotorProxy_writeMotorSpeed@@YAXQAUMotorProxy@@W4DirectionType@@I@Z
_TEXT	SEGMENT
tv151 = -348						; size = 4
tv145 = -348						; size = 4
$T1 = -340						; size = 20
$T2 = -312						; size = 20
_dAdjSpeed$ = -92					; size = 8
_dSpeed$ = -76						; size = 8
_dArmLength$ = -60					; size = 8
_mData$ = -28						; size = 20
__$ArrayPad$ = -4					; size = 4
_me$ = 8						; size = 4
_direction$ = 12					; size = 4
_speed$ = 16						; size = 4
?MotorProxy_writeMotorSpeed@@YAXQAUMotorProxy@@W4DirectionType@@I@Z PROC ; MotorProxy_writeMotorSpeed, COMDAT

; 129  : 	unsigned int speed) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 5c 01 00
	00		 sub	 esp, 348		; 0000015cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd a4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-348]
  00012	b9 57 00 00 00	 mov	 ecx, 87			; 00000057H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 130  : 	MotorData mData;
; 131  : 
; 132  : 	double dPi;
; 133  : 	double dArmLength;
; 134  : 	double dSpeed;
; 135  : 	double dAdjSpeed;
; 136  : 
; 137  : 	if (!me->motorAddr) {

  00028	8b 45 08	 mov	 eax, DWORD PTR _me$[ebp]
  0002b	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002e	75 05		 jne	 SHORT $LN2@MotorProxy

; 138  : 		return;

  00030	e9 3e 01 00 00	 jmp	 $LN1@MotorProxy
$LN2@MotorProxy:

; 139  : 	}
; 140  : 
; 141  : 	mData = unmarshal(*me->motorAddr);

  00035	8b 45 08	 mov	 eax, DWORD PTR _me$[ebp]
  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003c	52		 push	 edx
  0003d	8d 85 ac fe ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 ?unmarshal@@YA?AUMotorData@@I@Z ; unmarshal
  00049	83 c4 08	 add	 esp, 8
  0004c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004e	89 8d c8 fe ff
	ff		 mov	 DWORD PTR $T2[ebp], ecx
  00054	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00057	89 95 cc fe ff
	ff		 mov	 DWORD PTR $T2[ebp+4], edx
  0005d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00060	89 8d d0 fe ff
	ff		 mov	 DWORD PTR $T2[ebp+8], ecx
  00066	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00069	89 95 d4 fe ff
	ff		 mov	 DWORD PTR $T2[ebp+12], edx
  0006f	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00072	89 85 d8 fe ff
	ff		 mov	 DWORD PTR $T2[ebp+16], eax
  00078	8b 8d c8 fe ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp]
  0007e	89 4d e4	 mov	 DWORD PTR _mData$[ebp], ecx
  00081	8b 95 cc fe ff
	ff		 mov	 edx, DWORD PTR $T2[ebp+4]
  00087	89 55 e8	 mov	 DWORD PTR _mData$[ebp+4], edx
  0008a	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR $T2[ebp+8]
  00090	89 45 ec	 mov	 DWORD PTR _mData$[ebp+8], eax
  00093	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp+12]
  00099	89 4d f0	 mov	 DWORD PTR _mData$[ebp+12], ecx
  0009c	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR $T2[ebp+16]
  000a2	89 55 f4	 mov	 DWORD PTR _mData$[ebp+16], edx

; 142  : 	mData.direction = direction;

  000a5	8b 45 0c	 mov	 eax, DWORD PTR _direction$[ebp]
  000a8	89 45 e8	 mov	 DWORD PTR _mData$[ebp+4], eax

; 143  : 
; 144  : 	if (me->rotaryArmLength > 0) {

  000ab	8b 45 08	 mov	 eax, DWORD PTR _me$[ebp]
  000ae	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  000b2	0f 86 84 00 00
	00		 jbe	 $LN3@MotorProxy

; 145  : 		dSpeed = speed;

  000b8	8b 45 10	 mov	 eax, DWORD PTR _speed$[ebp]
  000bb	89 85 a4 fe ff
	ff		 mov	 DWORD PTR tv145[ebp], eax
  000c1	f2 0f 2a 85 a4
	fe ff ff	 cvtsi2sd xmm0, DWORD PTR tv145[ebp]
  000c9	8b 8d a4 fe ff
	ff		 mov	 ecx, DWORD PTR tv145[ebp]
  000cf	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  000d2	f2 0f 58 04 cd
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
  000db	f2 0f 11 45 b4	 movsd	 QWORD PTR _dSpeed$[ebp], xmm0

; 146  : 		dArmLength = me->rotaryArmLength;

  000e0	8b 45 08	 mov	 eax, DWORD PTR _me$[ebp]
  000e3	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000e6	89 8d a4 fe ff
	ff		 mov	 DWORD PTR tv151[ebp], ecx
  000ec	f2 0f 2a 85 a4
	fe ff ff	 cvtsi2sd xmm0, DWORD PTR tv151[ebp]
  000f4	8b 95 a4 fe ff
	ff		 mov	 edx, DWORD PTR tv151[ebp]
  000fa	c1 ea 1f	 shr	 edx, 31			; 0000001fH
  000fd	f2 0f 58 04 d5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
  00106	f2 0f 11 45 c4	 movsd	 QWORD PTR _dArmLength$[ebp], xmm0

; 147  : 		dAdjSpeed = dSpeed / 2.0 / 3.14159 / dArmLength * 10.0;

  0010b	f2 0f 10 45 b4	 movsd	 xmm0, QWORD PTR _dSpeed$[ebp]
  00110	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4000000000000000
  00118	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@400921f9f01b866e
  00120	f2 0f 5e 45 c4	 divsd	 xmm0, QWORD PTR _dArmLength$[ebp]
  00125	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4024000000000000
  0012d	f2 0f 11 45 a4	 movsd	 QWORD PTR _dAdjSpeed$[ebp], xmm0

; 148  : 		mData.speed = (int)dAdjSpeed;

  00132	f2 0f 2c 45 a4	 cvttsd2si eax, QWORD PTR _dAdjSpeed$[ebp]
  00137	89 45 ec	 mov	 DWORD PTR _mData$[ebp+8], eax

; 149  : 	}
; 150  : 	else {

  0013a	eb 06		 jmp	 SHORT $LN4@MotorProxy
$LN3@MotorProxy:

; 151  : 		mData.speed = speed;

  0013c	8b 45 10	 mov	 eax, DWORD PTR _speed$[ebp]
  0013f	89 45 ec	 mov	 DWORD PTR _mData$[ebp+8], eax
$LN4@MotorProxy:

; 152  : 	}
; 153  : 
; 154  : 	*me->motorAddr = marshal(mData);

  00142	83 ec 14	 sub	 esp, 20			; 00000014H
  00145	8b c4		 mov	 eax, esp
  00147	8b 4d e4	 mov	 ecx, DWORD PTR _mData$[ebp]
  0014a	89 08		 mov	 DWORD PTR [eax], ecx
  0014c	8b 55 e8	 mov	 edx, DWORD PTR _mData$[ebp+4]
  0014f	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00152	8b 4d ec	 mov	 ecx, DWORD PTR _mData$[ebp+8]
  00155	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00158	8b 55 f0	 mov	 edx, DWORD PTR _mData$[ebp+12]
  0015b	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  0015e	8b 4d f4	 mov	 ecx, DWORD PTR _mData$[ebp+16]
  00161	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00164	e8 00 00 00 00	 call	 ?marshal@@YAIUMotorData@@@Z ; marshal
  00169	83 c4 14	 add	 esp, 20			; 00000014H
  0016c	8b 55 08	 mov	 edx, DWORD PTR _me$[ebp]
  0016f	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00171	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@MotorProxy:

; 155  : }

  00173	52		 push	 edx
  00174	8b cd		 mov	 ecx, ebp
  00176	50		 push	 eax
  00177	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@MotorProxy
  0017d	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00182	58		 pop	 eax
  00183	5a		 pop	 edx
  00184	5f		 pop	 edi
  00185	5e		 pop	 esi
  00186	5b		 pop	 ebx
  00187	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0018a	33 cd		 xor	 ecx, ebp
  0018c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00191	81 c4 5c 01 00
	00		 add	 esp, 348		; 0000015cH
  00197	3b ec		 cmp	 ebp, esp
  00199	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0019e	8b e5		 mov	 esp, ebp
  001a0	5d		 pop	 ebp
  001a1	c3		 ret	 0
  001a2	66 90		 npad	 2
$LN8@MotorProxy:
  001a4	01 00 00 00	 DD	 1
  001a8	00 00 00 00	 DD	 $LN7@MotorProxy
$LN7@MotorProxy:
  001ac	e4 ff ff ff	 DD	 -28			; ffffffe4H
  001b0	14 00 00 00	 DD	 20			; 00000014H
  001b4	00 00 00 00	 DD	 $LN6@MotorProxy
$LN6@MotorProxy:
  001b8	6d		 DB	 109			; 0000006dH
  001b9	44		 DB	 68			; 00000044H
  001ba	61		 DB	 97			; 00000061H
  001bb	74		 DB	 116			; 00000074H
  001bc	61		 DB	 97			; 00000061H
  001bd	00		 DB	 0
?MotorProxy_writeMotorSpeed@@YAXQAUMotorProxy@@W4DirectionType@@I@Z ENDP ; MotorProxy_writeMotorSpeed
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\tim\school\level 6\ci6300 individual project\code\patterns\hardwarepatterns\hardwareproxypattern\motorproxy.cpp
;	COMDAT ?MotorProxy_enable@@YAXQAUMotorProxy@@@Z
_TEXT	SEGMENT
_me$ = 8						; size = 4
?MotorProxy_enable@@YAXQAUMotorProxy@@@Z PROC		; MotorProxy_enable, COMDAT

; 93   : void MotorProxy_enable(MotorProxy* const me) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 94   : 	if (!me->motorAddr) {

  0001e	8b 45 08	 mov	 eax, DWORD PTR _me$[ebp]
  00021	83 38 00	 cmp	 DWORD PTR [eax], 0
  00024	75 02		 jne	 SHORT $LN2@MotorProxy

; 95   : 		return;

  00026	eb 11		 jmp	 SHORT $LN1@MotorProxy
$LN2@MotorProxy:

; 96   : 	}
; 97   : 
; 98   : 	*me->motorAddr |= 1;

  00028	8b 45 08	 mov	 eax, DWORD PTR _me$[ebp]
  0002b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002f	83 ca 01	 or	 edx, 1
  00032	8b 45 08	 mov	 eax, DWORD PTR _me$[ebp]
  00035	8b 08		 mov	 ecx, DWORD PTR [eax]
  00037	89 11		 mov	 DWORD PTR [ecx], edx
$LN1@MotorProxy:

; 99   : }

  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?MotorProxy_enable@@YAXQAUMotorProxy@@@Z ENDP		; MotorProxy_enable
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\tim\school\level 6\ci6300 individual project\code\patterns\hardwarepatterns\hardwareproxypattern\motorproxy.cpp
;	COMDAT ?MotorProxy_disable@@YAXQAUMotorProxy@@@Z
_TEXT	SEGMENT
_me$ = 8						; size = 4
?MotorProxy_disable@@YAXQAUMotorProxy@@@Z PROC		; MotorProxy_disable, COMDAT

; 83   : void MotorProxy_disable(MotorProxy* const me) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 84   : 	if (!me->motorAddr) {

  0001e	8b 45 08	 mov	 eax, DWORD PTR _me$[ebp]
  00021	83 38 00	 cmp	 DWORD PTR [eax], 0
  00024	75 02		 jne	 SHORT $LN2@MotorProxy

; 85   : 		return;

  00026	eb 14		 jmp	 SHORT $LN1@MotorProxy
$LN2@MotorProxy:

; 86   : 	}
; 87   : 
; 88   : 	*me->motorAddr &= 0xFFFE;

  00028	8b 45 08	 mov	 eax, DWORD PTR _me$[ebp]
  0002b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002f	81 e2 fe ff 00
	00		 and	 edx, 65534		; 0000fffeH
  00035	8b 45 08	 mov	 eax, DWORD PTR _me$[ebp]
  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	89 11		 mov	 DWORD PTR [ecx], edx
$LN1@MotorProxy:

; 89   : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
?MotorProxy_disable@@YAXQAUMotorProxy@@@Z ENDP		; MotorProxy_disable
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\tim\school\level 6\ci6300 individual project\code\patterns\hardwarepatterns\hardwareproxypattern\motorproxy.cpp
;	COMDAT ?MotorProxy_Destroy@@YAXQAUMotorProxy@@@Z
_TEXT	SEGMENT
_me$ = 8						; size = 4
?MotorProxy_Destroy@@YAXQAUMotorProxy@@@Z PROC		; MotorProxy_Destroy, COMDAT

; 259  : void MotorProxy_Destroy(MotorProxy* const me) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 260  : 	if (me != NULL) {

  0001e	83 7d 08 00	 cmp	 DWORD PTR _me$[ebp], 0
  00022	74 0c		 je	 SHORT $LN2@MotorProxy

; 261  : 		MotorProxy_Cleanup(me);

  00024	8b 45 08	 mov	 eax, DWORD PTR _me$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ?MotorProxy_Cleanup@@YAXQAUMotorProxy@@@Z ; MotorProxy_Cleanup
  0002d	83 c4 04	 add	 esp, 4
$LN2@MotorProxy:

; 262  : 	}
; 263  : 
; 264  : 	free(me);

  00030	8b f4		 mov	 esi, esp
  00032	8b 45 08	 mov	 eax, DWORD PTR _me$[ebp]
  00035	50		 push	 eax
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0003c	83 c4 04	 add	 esp, 4
  0003f	3b f4		 cmp	 esi, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 265  : }

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004f	3b ec		 cmp	 ebp, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?MotorProxy_Destroy@@YAXQAUMotorProxy@@@Z ENDP		; MotorProxy_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\tim\school\level 6\ci6300 individual project\code\patterns\hardwarepatterns\hardwareproxypattern\motorproxy.cpp
;	COMDAT ?MotorProxy_Create@@YAPAUMotorProxy@@XZ
_TEXT	SEGMENT
_me$ = -8						; size = 4
?MotorProxy_Create@@YAPAUMotorProxy@@XZ PROC		; MotorProxy_Create, COMDAT

; 247  : MotorProxy* MotorProxy_Create(void) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 248  : 	MotorProxy* me = (MotorProxy*)malloc(sizeof(MotorProxy));

  0001e	8b f4		 mov	 esi, esp
  00020	6a 08		 push	 8
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00028	83 c4 04	 add	 esp, 4
  0002b	3b f4		 cmp	 esi, esp
  0002d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00032	89 45 f8	 mov	 DWORD PTR _me$[ebp], eax

; 249  : 
; 250  : 	if (me != NULL) {

  00035	83 7d f8 00	 cmp	 DWORD PTR _me$[ebp], 0
  00039	74 0c		 je	 SHORT $LN2@MotorProxy

; 251  : 		MotorProxy_Init(me);

  0003b	8b 45 f8	 mov	 eax, DWORD PTR _me$[ebp]
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?MotorProxy_Init@@YAXQAUMotorProxy@@@Z ; MotorProxy_Init
  00044	83 c4 04	 add	 esp, 4
$LN2@MotorProxy:

; 252  : 	}
; 253  : 
; 254  : 	return me;

  00047	8b 45 f8	 mov	 eax, DWORD PTR _me$[ebp]

; 255  : }

  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx
  0004d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00053	3b ec		 cmp	 ebp, esp
  00055	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
?MotorProxy_Create@@YAPAUMotorProxy@@XZ ENDP		; MotorProxy_Create
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\tim\school\level 6\ci6300 individual project\code\patterns\hardwarepatterns\hardwareproxypattern\motorproxy.cpp
;	COMDAT ?MotorProxy_initialize@@YAXQAUMotorProxy@@@Z
_TEXT	SEGMENT
_mData$ = -28						; size = 20
__$ArrayPad$ = -4					; size = 4
_me$ = 8						; size = 4
?MotorProxy_initialize@@YAXQAUMotorProxy@@@Z PROC	; MotorProxy_initialize, COMDAT

; 103  : void MotorProxy_initialize(MotorProxy* const me) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 20 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-224]
  00012	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 104  : 	MotorData mData;
; 105  : 
; 106  : 	if (!me->motorAddr) {

  00028	8b 45 08	 mov	 eax, DWORD PTR _me$[ebp]
  0002b	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002e	75 02		 jne	 SHORT $LN2@MotorProxy

; 107  : 		return;

  00030	eb 63		 jmp	 SHORT $LN1@MotorProxy
$LN2@MotorProxy:

; 108  : 	}
; 109  : 
; 110  : 	mData.on_off = 1;

  00032	c6 45 e4 01	 mov	 BYTE PTR _mData$[ebp], 1

; 111  : 	mData.direction = NO_DIRECTION;

  00036	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _mData$[ebp+4], 0

; 112  : 	mData.speed = 0;

  0003d	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _mData$[ebp+8], 0

; 113  : 	mData.errorStatus = 0;

  00044	c6 45 f0 00	 mov	 BYTE PTR _mData$[ebp+12], 0

; 114  : 	mData.noPowerError = 0;

  00048	c6 45 f1 00	 mov	 BYTE PTR _mData$[ebp+13], 0

; 115  : 	mData.noTorqueError = 0;

  0004c	c6 45 f2 00	 mov	 BYTE PTR _mData$[ebp+14], 0

; 116  : 	mData.BITError = 0;

  00050	c6 45 f3 00	 mov	 BYTE PTR _mData$[ebp+15], 0

; 117  : 	mData.overTemperatureError = 0;

  00054	c6 45 f4 00	 mov	 BYTE PTR _mData$[ebp+16], 0

; 118  : 	mData.reservedError1 = 0;

  00058	c6 45 f5 00	 mov	 BYTE PTR _mData$[ebp+17], 0

; 119  : 	mData.reservedError2 = 0;

  0005c	c6 45 f6 00	 mov	 BYTE PTR _mData$[ebp+18], 0

; 120  : 	mData.unknownError = 0;

  00060	c6 45 f7 00	 mov	 BYTE PTR _mData$[ebp+19], 0

; 121  : 
; 122  : 	*me->motorAddr = marshal(mData);

  00064	83 ec 14	 sub	 esp, 20			; 00000014H
  00067	8b c4		 mov	 eax, esp
  00069	8b 4d e4	 mov	 ecx, DWORD PTR _mData$[ebp]
  0006c	89 08		 mov	 DWORD PTR [eax], ecx
  0006e	8b 55 e8	 mov	 edx, DWORD PTR _mData$[ebp+4]
  00071	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00074	8b 4d ec	 mov	 ecx, DWORD PTR _mData$[ebp+8]
  00077	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0007a	8b 55 f0	 mov	 edx, DWORD PTR _mData$[ebp+12]
  0007d	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00080	8b 4d f4	 mov	 ecx, DWORD PTR _mData$[ebp+16]
  00083	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00086	e8 00 00 00 00	 call	 ?marshal@@YAIUMotorData@@@Z ; marshal
  0008b	83 c4 14	 add	 esp, 20			; 00000014H
  0008e	8b 55 08	 mov	 edx, DWORD PTR _me$[ebp]
  00091	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00093	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@MotorProxy:

; 123  : }

  00095	52		 push	 edx
  00096	8b cd		 mov	 ecx, ebp
  00098	50		 push	 eax
  00099	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@MotorProxy
  0009f	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000a4	58		 pop	 eax
  000a5	5a		 pop	 edx
  000a6	5f		 pop	 edi
  000a7	5e		 pop	 esi
  000a8	5b		 pop	 ebx
  000a9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ac	33 cd		 xor	 ecx, ebp
  000ae	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b3	81 c4 e0 00 00
	00		 add	 esp, 224		; 000000e0H
  000b9	3b ec		 cmp	 ebp, esp
  000bb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
$LN6@MotorProxy:
  000c4	01 00 00 00	 DD	 1
  000c8	00 00 00 00	 DD	 $LN5@MotorProxy
$LN5@MotorProxy:
  000cc	e4 ff ff ff	 DD	 -28			; ffffffe4H
  000d0	14 00 00 00	 DD	 20			; 00000014H
  000d4	00 00 00 00	 DD	 $LN4@MotorProxy
$LN4@MotorProxy:
  000d8	6d		 DB	 109			; 0000006dH
  000d9	44		 DB	 68			; 00000044H
  000da	61		 DB	 97			; 00000061H
  000db	74		 DB	 116			; 00000074H
  000dc	61		 DB	 97			; 00000061H
  000dd	00		 DB	 0
?MotorProxy_initialize@@YAXQAUMotorProxy@@@Z ENDP	; MotorProxy_initialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\tim\school\level 6\ci6300 individual project\code\patterns\hardwarepatterns\hardwareproxypattern\motorproxy.cpp
;	COMDAT ?MotorProxy_configure@@YAXQAUMotorProxy@@IPAI@Z
_TEXT	SEGMENT
_me$ = 8						; size = 4
_length$ = 12						; size = 4
_location$ = 16						; size = 4
?MotorProxy_configure@@YAXQAUMotorProxy@@IPAI@Z PROC	; MotorProxy_configure, COMDAT

; 76   : 	unsigned int* location) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 77   : 	me->rotaryArmLength = length;

  0001e	8b 45 08	 mov	 eax, DWORD PTR _me$[ebp]
  00021	8b 4d 0c	 mov	 ecx, DWORD PTR _length$[ebp]
  00024	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 78   : 	me->motorAddr = location;

  00027	8b 45 08	 mov	 eax, DWORD PTR _me$[ebp]
  0002a	8b 4d 10	 mov	 ecx, DWORD PTR _location$[ebp]
  0002d	89 08		 mov	 DWORD PTR [eax], ecx

; 79   : }

  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
?MotorProxy_configure@@YAXQAUMotorProxy@@IPAI@Z ENDP	; MotorProxy_configure
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\tim\school\level 6\ci6300 individual project\code\patterns\hardwarepatterns\hardwareproxypattern\motorproxy.cpp
;	COMDAT ?MotorProxy_clearErrorStatus@@YAXQAUMotorProxy@@@Z
_TEXT	SEGMENT
_me$ = 8						; size = 4
?MotorProxy_clearErrorStatus@@YAXQAUMotorProxy@@@Z PROC	; MotorProxy_clearErrorStatus, COMDAT

; 65   : void MotorProxy_clearErrorStatus(MotorProxy* const me) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 66   : 	if (!me->motorAddr) {

  0001e	8b 45 08	 mov	 eax, DWORD PTR _me$[ebp]
  00021	83 38 00	 cmp	 DWORD PTR [eax], 0
  00024	75 02		 jne	 SHORT $LN2@MotorProxy

; 67   : 		return;

  00026	eb 14		 jmp	 SHORT $LN1@MotorProxy
$LN2@MotorProxy:

; 68   : 	}
; 69   : 
; 70   : 	*me->motorAddr &= 0xFF;

  00028	8b 45 08	 mov	 eax, DWORD PTR _me$[ebp]
  0002b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002f	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00035	8b 45 08	 mov	 eax, DWORD PTR _me$[ebp]
  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	89 11		 mov	 DWORD PTR [ecx], edx
$LN1@MotorProxy:

; 71   : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
?MotorProxy_clearErrorStatus@@YAXQAUMotorProxy@@@Z ENDP	; MotorProxy_clearErrorStatus
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\tim\school\level 6\ci6300 individual project\code\patterns\hardwarepatterns\hardwareproxypattern\motorproxy.cpp
;	COMDAT ?MotorProxy_accessMotorState@@YAIQAUMotorProxy@@@Z
_TEXT	SEGMENT
$T1 = -276						; size = 20
$T2 = -248						; size = 20
_mData$ = -28						; size = 20
__$ArrayPad$ = -4					; size = 4
_me$ = 8						; size = 4
?MotorProxy_accessMotorState@@YAIQAUMotorProxy@@@Z PROC	; MotorProxy_accessMotorState, COMDAT

; 51   : unsigned int MotorProxy_accessMotorState(MotorProxy* const me) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd e8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-280]
  00012	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 52   : 	MotorData mData;
; 53   : 
; 54   : 	if (!me->motorAddr) {

  00028	8b 45 08	 mov	 eax, DWORD PTR _me$[ebp]
  0002b	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002e	75 04		 jne	 SHORT $LN2@MotorProxy

; 55   : 		return 0;

  00030	33 c0		 xor	 eax, eax
  00032	eb 74		 jmp	 SHORT $LN1@MotorProxy
$LN2@MotorProxy:

; 56   : 	}
; 57   : 
; 58   : 	mData = unmarshal(*me->motorAddr);

  00034	8b 45 08	 mov	 eax, DWORD PTR _me$[ebp]
  00037	8b 08		 mov	 ecx, DWORD PTR [eax]
  00039	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003b	52		 push	 edx
  0003c	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ?unmarshal@@YA?AUMotorData@@I@Z ; unmarshal
  00048	83 c4 08	 add	 esp, 8
  0004b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004d	89 8d 08 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], ecx
  00053	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00056	89 95 0c ff ff
	ff		 mov	 DWORD PTR $T2[ebp+4], edx
  0005c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005f	89 8d 10 ff ff
	ff		 mov	 DWORD PTR $T2[ebp+8], ecx
  00065	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00068	89 95 14 ff ff
	ff		 mov	 DWORD PTR $T2[ebp+12], edx
  0006e	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00071	89 85 18 ff ff
	ff		 mov	 DWORD PTR $T2[ebp+16], eax
  00077	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp]
  0007d	89 4d e4	 mov	 DWORD PTR _mData$[ebp], ecx
  00080	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR $T2[ebp+4]
  00086	89 55 e8	 mov	 DWORD PTR _mData$[ebp+4], edx
  00089	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR $T2[ebp+8]
  0008f	89 45 ec	 mov	 DWORD PTR _mData$[ebp+8], eax
  00092	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp+12]
  00098	89 4d f0	 mov	 DWORD PTR _mData$[ebp+12], ecx
  0009b	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR $T2[ebp+16]
  000a1	89 55 f4	 mov	 DWORD PTR _mData$[ebp+16], edx

; 59   : 
; 60   : 	return mData.errorStatus;

  000a4	0f b6 45 f0	 movzx	 eax, BYTE PTR _mData$[ebp+12]
$LN1@MotorProxy:

; 61   : }

  000a8	52		 push	 edx
  000a9	8b cd		 mov	 ecx, ebp
  000ab	50		 push	 eax
  000ac	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@MotorProxy
  000b2	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000b7	58		 pop	 eax
  000b8	5a		 pop	 edx
  000b9	5f		 pop	 edi
  000ba	5e		 pop	 esi
  000bb	5b		 pop	 ebx
  000bc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000bf	33 cd		 xor	 ecx, ebp
  000c1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c6	81 c4 18 01 00
	00		 add	 esp, 280		; 00000118H
  000cc	3b ec		 cmp	 ebp, esp
  000ce	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d3	8b e5		 mov	 esp, ebp
  000d5	5d		 pop	 ebp
  000d6	c3		 ret	 0
  000d7	90		 npad	 1
$LN6@MotorProxy:
  000d8	01 00 00 00	 DD	 1
  000dc	00 00 00 00	 DD	 $LN5@MotorProxy
$LN5@MotorProxy:
  000e0	e4 ff ff ff	 DD	 -28			; ffffffe4H
  000e4	14 00 00 00	 DD	 20			; 00000014H
  000e8	00 00 00 00	 DD	 $LN4@MotorProxy
$LN4@MotorProxy:
  000ec	6d		 DB	 109			; 0000006dH
  000ed	44		 DB	 68			; 00000044H
  000ee	61		 DB	 97			; 00000061H
  000ef	74		 DB	 116			; 00000074H
  000f0	61		 DB	 97			; 00000061H
  000f1	00		 DB	 0
?MotorProxy_accessMotorState@@YAIQAUMotorProxy@@@Z ENDP	; MotorProxy_accessMotorState
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\tim\school\level 6\ci6300 individual project\code\patterns\hardwarepatterns\hardwareproxypattern\motorproxy.cpp
;	COMDAT ?MotorProxy_accessMotorSpeed@@YAIQAUMotorProxy@@@Z
_TEXT	SEGMENT
$T1 = -276						; size = 20
$T2 = -248						; size = 20
_mData$ = -28						; size = 20
__$ArrayPad$ = -4					; size = 4
_me$ = 8						; size = 4
?MotorProxy_accessMotorSpeed@@YAIQAUMotorProxy@@@Z PROC	; MotorProxy_accessMotorSpeed, COMDAT

; 37   : unsigned int MotorProxy_accessMotorSpeed(MotorProxy* const me) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd e8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-280]
  00012	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 38   : 	MotorData mData;
; 39   : 
; 40   : 	if (!me->motorAddr) {

  00028	8b 45 08	 mov	 eax, DWORD PTR _me$[ebp]
  0002b	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002e	75 04		 jne	 SHORT $LN2@MotorProxy

; 41   : 		return 0;

  00030	33 c0		 xor	 eax, eax
  00032	eb 73		 jmp	 SHORT $LN1@MotorProxy
$LN2@MotorProxy:

; 42   : 	}
; 43   : 
; 44   : 	mData = unmarshal(*me->motorAddr);

  00034	8b 45 08	 mov	 eax, DWORD PTR _me$[ebp]
  00037	8b 08		 mov	 ecx, DWORD PTR [eax]
  00039	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003b	52		 push	 edx
  0003c	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ?unmarshal@@YA?AUMotorData@@I@Z ; unmarshal
  00048	83 c4 08	 add	 esp, 8
  0004b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004d	89 8d 08 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], ecx
  00053	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00056	89 95 0c ff ff
	ff		 mov	 DWORD PTR $T2[ebp+4], edx
  0005c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005f	89 8d 10 ff ff
	ff		 mov	 DWORD PTR $T2[ebp+8], ecx
  00065	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00068	89 95 14 ff ff
	ff		 mov	 DWORD PTR $T2[ebp+12], edx
  0006e	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00071	89 85 18 ff ff
	ff		 mov	 DWORD PTR $T2[ebp+16], eax
  00077	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp]
  0007d	89 4d e4	 mov	 DWORD PTR _mData$[ebp], ecx
  00080	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR $T2[ebp+4]
  00086	89 55 e8	 mov	 DWORD PTR _mData$[ebp+4], edx
  00089	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR $T2[ebp+8]
  0008f	89 45 ec	 mov	 DWORD PTR _mData$[ebp+8], eax
  00092	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp+12]
  00098	89 4d f0	 mov	 DWORD PTR _mData$[ebp+12], ecx
  0009b	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR $T2[ebp+16]
  000a1	89 55 f4	 mov	 DWORD PTR _mData$[ebp+16], edx

; 45   : 
; 46   : 	return mData.speed;

  000a4	8b 45 ec	 mov	 eax, DWORD PTR _mData$[ebp+8]
$LN1@MotorProxy:

; 47   : }

  000a7	52		 push	 edx
  000a8	8b cd		 mov	 ecx, ebp
  000aa	50		 push	 eax
  000ab	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@MotorProxy
  000b1	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000b6	58		 pop	 eax
  000b7	5a		 pop	 edx
  000b8	5f		 pop	 edi
  000b9	5e		 pop	 esi
  000ba	5b		 pop	 ebx
  000bb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000be	33 cd		 xor	 ecx, ebp
  000c0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c5	81 c4 18 01 00
	00		 add	 esp, 280		; 00000118H
  000cb	3b ec		 cmp	 ebp, esp
  000cd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d2	8b e5		 mov	 esp, ebp
  000d4	5d		 pop	 ebp
  000d5	c3		 ret	 0
  000d6	66 90		 npad	 2
$LN6@MotorProxy:
  000d8	01 00 00 00	 DD	 1
  000dc	00 00 00 00	 DD	 $LN5@MotorProxy
$LN5@MotorProxy:
  000e0	e4 ff ff ff	 DD	 -28			; ffffffe4H
  000e4	14 00 00 00	 DD	 20			; 00000014H
  000e8	00 00 00 00	 DD	 $LN4@MotorProxy
$LN4@MotorProxy:
  000ec	6d		 DB	 109			; 0000006dH
  000ed	44		 DB	 68			; 00000044H
  000ee	61		 DB	 97			; 00000061H
  000ef	74		 DB	 116			; 00000074H
  000f0	61		 DB	 97			; 00000061H
  000f1	00		 DB	 0
?MotorProxy_accessMotorSpeed@@YAIQAUMotorProxy@@@Z ENDP	; MotorProxy_accessMotorSpeed
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\tim\school\level 6\ci6300 individual project\code\patterns\hardwarepatterns\hardwareproxypattern\motorproxy.cpp
;	COMDAT ?MotorProxy_accessMotorDirection@@YA?AW4DirectionType@@QAUMotorProxy@@@Z
_TEXT	SEGMENT
$T1 = -276						; size = 20
$T2 = -248						; size = 20
_mData$ = -28						; size = 20
__$ArrayPad$ = -4					; size = 4
_me$ = 8						; size = 4
?MotorProxy_accessMotorDirection@@YA?AW4DirectionType@@QAUMotorProxy@@@Z PROC ; MotorProxy_accessMotorDirection, COMDAT

; 23   : DirectionType MotorProxy_accessMotorDirection(MotorProxy* const me) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd e8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-280]
  00012	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 24   : 	MotorData mData;
; 25   : 
; 26   : 	if (!me->motorAddr) {

  00028	8b 45 08	 mov	 eax, DWORD PTR _me$[ebp]
  0002b	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002e	75 04		 jne	 SHORT $LN2@MotorProxy

; 27   : 		return NO_DIRECTION;

  00030	33 c0		 xor	 eax, eax
  00032	eb 73		 jmp	 SHORT $LN1@MotorProxy
$LN2@MotorProxy:

; 28   : 	}
; 29   : 
; 30   : mData = unmarshal(*me->motorAddr);

  00034	8b 45 08	 mov	 eax, DWORD PTR _me$[ebp]
  00037	8b 08		 mov	 ecx, DWORD PTR [eax]
  00039	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003b	52		 push	 edx
  0003c	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ?unmarshal@@YA?AUMotorData@@I@Z ; unmarshal
  00048	83 c4 08	 add	 esp, 8
  0004b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004d	89 8d 08 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], ecx
  00053	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00056	89 95 0c ff ff
	ff		 mov	 DWORD PTR $T2[ebp+4], edx
  0005c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005f	89 8d 10 ff ff
	ff		 mov	 DWORD PTR $T2[ebp+8], ecx
  00065	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00068	89 95 14 ff ff
	ff		 mov	 DWORD PTR $T2[ebp+12], edx
  0006e	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00071	89 85 18 ff ff
	ff		 mov	 DWORD PTR $T2[ebp+16], eax
  00077	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp]
  0007d	89 4d e4	 mov	 DWORD PTR _mData$[ebp], ecx
  00080	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR $T2[ebp+4]
  00086	89 55 e8	 mov	 DWORD PTR _mData$[ebp+4], edx
  00089	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR $T2[ebp+8]
  0008f	89 45 ec	 mov	 DWORD PTR _mData$[ebp+8], eax
  00092	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp+12]
  00098	89 4d f0	 mov	 DWORD PTR _mData$[ebp+12], ecx
  0009b	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR $T2[ebp+16]
  000a1	89 55 f4	 mov	 DWORD PTR _mData$[ebp+16], edx

; 31   : 
; 32   : return mData.direction;

  000a4	8b 45 e8	 mov	 eax, DWORD PTR _mData$[ebp+4]
$LN1@MotorProxy:

; 33   : }

  000a7	52		 push	 edx
  000a8	8b cd		 mov	 ecx, ebp
  000aa	50		 push	 eax
  000ab	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@MotorProxy
  000b1	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000b6	58		 pop	 eax
  000b7	5a		 pop	 edx
  000b8	5f		 pop	 edi
  000b9	5e		 pop	 esi
  000ba	5b		 pop	 ebx
  000bb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000be	33 cd		 xor	 ecx, ebp
  000c0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c5	81 c4 18 01 00
	00		 add	 esp, 280		; 00000118H
  000cb	3b ec		 cmp	 ebp, esp
  000cd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d2	8b e5		 mov	 esp, ebp
  000d4	5d		 pop	 ebp
  000d5	c3		 ret	 0
  000d6	66 90		 npad	 2
$LN6@MotorProxy:
  000d8	01 00 00 00	 DD	 1
  000dc	00 00 00 00	 DD	 $LN5@MotorProxy
$LN5@MotorProxy:
  000e0	e4 ff ff ff	 DD	 -28			; ffffffe4H
  000e4	14 00 00 00	 DD	 20			; 00000014H
  000e8	00 00 00 00	 DD	 $LN4@MotorProxy
$LN4@MotorProxy:
  000ec	6d		 DB	 109			; 0000006dH
  000ed	44		 DB	 68			; 00000044H
  000ee	61		 DB	 97			; 00000061H
  000ef	74		 DB	 116			; 00000074H
  000f0	61		 DB	 97			; 00000061H
  000f1	00		 DB	 0
?MotorProxy_accessMotorDirection@@YA?AW4DirectionType@@QAUMotorProxy@@@Z ENDP ; MotorProxy_accessMotorDirection
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\tim\school\level 6\ci6300 individual project\code\patterns\hardwarepatterns\hardwareproxypattern\motorproxy.cpp
;	COMDAT ?MotorProxy_Cleanup@@YAXQAUMotorProxy@@@Z
_TEXT	SEGMENT
_me$ = 8						; size = 4
?MotorProxy_Cleanup@@YAXQAUMotorProxy@@@Z PROC		; MotorProxy_Cleanup, COMDAT

; 17   : void MotorProxy_Cleanup(MotorProxy* const me) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 18   : 
; 19   : }

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
?MotorProxy_Cleanup@@YAXQAUMotorProxy@@@Z ENDP		; MotorProxy_Cleanup
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\tim\school\level 6\ci6300 individual project\code\patterns\hardwarepatterns\hardwareproxypattern\motorproxy.cpp
;	COMDAT ?MotorProxy_Init@@YAXQAUMotorProxy@@@Z
_TEXT	SEGMENT
_me$ = 8						; size = 4
?MotorProxy_Init@@YAXQAUMotorProxy@@@Z PROC		; MotorProxy_Init, COMDAT

; 11   : void MotorProxy_Init(MotorProxy* const me) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 12   : 	me->motorAddr = NULL;

  0001e	8b 45 08	 mov	 eax, DWORD PTR _me$[ebp]
  00021	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 13   : }

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
?MotorProxy_Init@@YAXQAUMotorProxy@@@Z ENDP		; MotorProxy_Init
_TEXT	ENDS
END
